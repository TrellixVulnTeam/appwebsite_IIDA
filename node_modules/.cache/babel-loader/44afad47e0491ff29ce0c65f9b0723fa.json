{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n/********************************************************************************\n *   Ledger Node JS API\n *   (c) 2016-2017 Ledger\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n// FIXME drop:\n\n\nimport { splitPath, foreach } from \"./utils\";\nimport { log } from \"@ledgerhq/logs\";\nimport { EthAppPleaseEnableContractData } from \"@ledgerhq/errors\";\nimport { BigNumber } from \"bignumber.js\";\nimport { ethers } from \"ethers\";\nimport { byContractAddressAndChainId } from \"./erc20\";\nimport { loadInfosForContractMethod } from \"./contracts\";\nimport { getNFTInfo, loadNftPlugin } from \"./nfts\";\nvar starkQuantizationTypeMap = {\n  eth: 1,\n  erc20: 2,\n  erc721: 3,\n  erc20mintable: 4,\n  erc721mintable: 5\n};\n\nfunction hexBuffer(str) {\n  return Buffer.from(str.startsWith(\"0x\") ? str.slice(2) : str, \"hex\");\n}\n\nfunction maybeHexBuffer(str) {\n  if (!str) return null;\n  return hexBuffer(str);\n}\n\nvar remapTransactionRelatedErrors = function (e) {\n  if (e && e.statusCode === 0x6a80) {\n    return new EthAppPleaseEnableContractData(\"Please enable Blind signing or Contract data in the Ethereum app Settings\");\n  }\n\n  return e;\n};\n/**\n * Ethereum API\n *\n * @example\n * import Eth from \"@ledgerhq/hw-app-eth\";\n * const eth = new Eth(transport)\n */\n\n\nvar Eth = function () {\n  function Eth(transport, scrambleKey, loadConfig) {\n    if (scrambleKey === void 0) {\n      scrambleKey = \"w0w\";\n    }\n\n    if (loadConfig === void 0) {\n      loadConfig = {};\n    }\n\n    this.transport = transport;\n    this.loadConfig = loadConfig;\n    transport.decorateAppAPIMethods(this, [\"getAddress\", \"provideERC20TokenInformation\", \"signTransaction\", \"signPersonalMessage\", \"getAppConfiguration\", \"signEIP712HashedMessage\", \"starkGetPublicKey\", \"starkSignOrder\", \"starkSignOrder_v2\", \"starkSignTransfer\", \"starkSignTransfer_v2\", \"starkProvideQuantum\", \"starkProvideQuantum_v2\", \"starkUnsafeSign\", \"eth2GetPublicKey\", \"eth2SetWithdrawalIndex\", \"setExternalPlugin\", \"setPlugin\"], scrambleKey);\n  }\n\n  Eth.prototype.setLoadConfig = function (loadConfig) {\n    this.loadConfig = loadConfig;\n  };\n  /**\n   * get Ethereum address for a given BIP 32 path.\n   * @param path a path in BIP 32 format\n   * @option boolDisplay optionally enable or not the display\n   * @option boolChaincode optionally enable or not the chaincode request\n   * @return an object with a publicKey, address and (optionally) chainCode\n   * @example\n   * eth.getAddress(\"44'/60'/0'/0/0\").then(o => o.address)\n   */\n\n\n  Eth.prototype.getAddress = function (path, boolDisplay, boolChaincode) {\n    var paths = splitPath(path);\n    var buffer = Buffer.alloc(1 + paths.length * 4);\n    buffer[0] = paths.length;\n    paths.forEach(function (element, index) {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    return this.transport.send(0xe0, 0x02, boolDisplay ? 0x01 : 0x00, boolChaincode ? 0x01 : 0x00, buffer).then(function (response) {\n      var publicKeyLength = response[0];\n      var addressLength = response[1 + publicKeyLength];\n      return {\n        publicKey: response.slice(1, 1 + publicKeyLength).toString(\"hex\"),\n        address: \"0x\" + response.slice(1 + publicKeyLength + 1, 1 + publicKeyLength + 1 + addressLength).toString(\"ascii\"),\n        chainCode: boolChaincode ? response.slice(1 + publicKeyLength + 1 + addressLength, 1 + publicKeyLength + 1 + addressLength + 32).toString(\"hex\") : undefined\n      };\n    });\n  };\n  /**\n   * This commands provides a trusted description of an ERC 20 token\n   * to associate a contract address with a ticker and number of decimals.\n   *\n   * It shall be run immediately before performing a transaction involving a contract\n   * calling this contract address to display the proper token information to the user if necessary.\n   *\n   * @param {*} info: a blob from \"erc20.js\" utilities that contains all token information.\n   *\n   * @example\n   * import { byContractAddressAndChainId } from \"@ledgerhq/hw-app-eth/erc20\"\n   * const zrxInfo = byContractAddressAndChainId(\"0xe41d2489571d322189246dafa5ebde1f4699f498\", chainId)\n   * if (zrxInfo) await appEth.provideERC20TokenInformation(zrxInfo)\n   * const signed = await appEth.signTransaction(path, rawTxHex)\n   */\n\n\n  Eth.prototype.provideERC20TokenInformation = function (_a) {\n    var data = _a.data;\n    return provideERC20TokenInformation(this.transport, data);\n  };\n  /**\n   * You can sign a transaction and retrieve v, r, s given the raw transaction and the BIP 32 path of the account to sign\n   * @example\n   eth.signTransaction(\"44'/60'/0'/0/0\", \"e8018504e3b292008252089428ee52a8f3d6e5d15f8b131996950d7f296c7952872bd72a2487400080\").then(result => ...)\n   */\n\n\n  Eth.prototype.signTransaction = function (path, rawTxHex) {\n    return __awaiter(this, void 0, void 0, function () {\n      var paths, offset, rawTx, VALID_TYPES, txType, rlpData, toSend, response, rlpTx, vrsOffset, chainId, chainIdTruncated, rlpDecoded, decodedTx, rlpVrs, sizeOfListLen, chainIdSrc, chainIdTruncatedBuf, _loop_1, provideForContract, selector, nftPluginPayload, infos, plugin, payload, signature, erc20OfInterest, abi, contract, args, erc20OfInterest_1, erc20OfInterest_1_1, address, e_1_1;\n\n      var e_1, _a;\n\n      var _this = this;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            paths = splitPath(path);\n            offset = 0;\n            rawTx = Buffer.from(rawTxHex, \"hex\");\n            VALID_TYPES = [1, 2];\n            txType = VALID_TYPES.includes(rawTx[0]) ? rawTx[0] : null;\n            rlpData = txType === null ? rawTx : rawTx.slice(1, rawTxHex.length);\n            toSend = [];\n            rlpTx = ethers.utils.RLP.decode(rlpData).map(function (hex) {\n              return Buffer.from(hex.slice(2), \"hex\");\n            });\n            vrsOffset = 0;\n            chainId = new BigNumber(0);\n            chainIdTruncated = 0;\n            rlpDecoded = ethers.utils.RLP.decode(rlpData);\n\n            if (txType === 2) {\n              // EIP1559\n              decodedTx = {\n                data: rlpDecoded[7],\n                to: rlpDecoded[5],\n                chainId: rlpTx[0]\n              };\n            } else if (txType === 1) {\n              // EIP2930\n              decodedTx = {\n                data: rlpDecoded[6],\n                to: rlpDecoded[4],\n                chainId: rlpTx[0]\n              };\n            } else {\n              // Legacy tx\n              decodedTx = {\n                data: rlpDecoded[5],\n                to: rlpDecoded[3],\n                // Default to 1 for non EIP 155 txs\n                chainId: rlpTx.length > 6 ? rlpTx[6] : Buffer.from(\"0x01\", \"hex\")\n              };\n            }\n\n            if (txType === null && rlpTx.length > 6) {\n              rlpVrs = Buffer.from(ethers.utils.RLP.encode(rlpTx.slice(-3)).slice(2), \"hex\");\n              vrsOffset = rawTx.length - (rlpVrs.length - 1); // First byte > 0xf7 means the length of the list length doesn't fit in a single byte.\n\n              if (rlpVrs[0] > 0xf7) {\n                // Increment vrsOffset to account for that extra byte.\n                vrsOffset++;\n                sizeOfListLen = rlpVrs[0] - 0xf7; // Increase rlpOffset by the size of the list length.\n\n                vrsOffset += sizeOfListLen - 1;\n              }\n            }\n\n            chainIdSrc = decodedTx.chainId;\n\n            if (chainIdSrc) {\n              // Using BigNumber because chainID could be any uint256.\n              chainId = new BigNumber(chainIdSrc.toString(\"hex\"), 16);\n              chainIdTruncatedBuf = Buffer.alloc(4);\n\n              if (chainIdSrc.length > 4) {\n                chainIdSrc.copy(chainIdTruncatedBuf);\n              } else {\n                chainIdSrc.copy(chainIdTruncatedBuf, 4 - chainIdSrc.length);\n              }\n\n              chainIdTruncated = chainIdTruncatedBuf.readUInt32BE(0);\n            }\n\n            _loop_1 = function () {\n              var maxChunkSize = offset === 0 ? 150 - 1 - paths.length * 4 : 150;\n              var chunkSize = offset + maxChunkSize > rawTx.length ? rawTx.length - offset : maxChunkSize;\n\n              if (vrsOffset != 0 && offset + chunkSize >= vrsOffset) {\n                // Make sure that the chunk doesn't end right on the EIP 155 marker if set\n                chunkSize = rawTx.length - offset;\n              }\n\n              var buffer = Buffer.alloc(offset === 0 ? 1 + paths.length * 4 + chunkSize : chunkSize);\n\n              if (offset === 0) {\n                buffer[0] = paths.length;\n                paths.forEach(function (element, index) {\n                  buffer.writeUInt32BE(element, 1 + 4 * index);\n                });\n                rawTx.copy(buffer, 1 + 4 * paths.length, offset, offset + chunkSize);\n              } else {\n                rawTx.copy(buffer, 0, offset, offset + chunkSize);\n              }\n\n              toSend.push(buffer);\n              offset += chunkSize;\n            };\n\n            while (offset !== rawTx.length) {\n              _loop_1();\n            }\n\n            provideForContract = function (address) {\n              return __awaiter(_this, void 0, void 0, function () {\n                var nftInfo, erc20Info;\n                return __generator(this, function (_a) {\n                  switch (_a.label) {\n                    case 0:\n                      return [4\n                      /*yield*/\n                      , getNFTInfo(address, chainIdTruncated, this.loadConfig)];\n\n                    case 1:\n                      nftInfo = _a.sent();\n                      if (!nftInfo) return [3\n                      /*break*/\n                      , 3];\n                      log(\"ethereum\", \"loading nft info for \" + nftInfo.contractAddress + \" (\" + nftInfo.collectionName + \")\");\n                      return [4\n                      /*yield*/\n                      , provideNFTInformation(this.transport, nftInfo.data)];\n\n                    case 2:\n                      _a.sent();\n\n                      return [3\n                      /*break*/\n                      , 5];\n\n                    case 3:\n                      erc20Info = byContractAddressAndChainId(address, chainIdTruncated);\n                      if (!erc20Info) return [3\n                      /*break*/\n                      , 5];\n                      log(\"ethereum\", \"loading erc20token info for \" + erc20Info.contractAddress + \" (\" + erc20Info.ticker + \")\");\n                      return [4\n                      /*yield*/\n                      , provideERC20TokenInformation(this.transport, erc20Info.data)];\n\n                    case 4:\n                      _a.sent();\n\n                      _a.label = 5;\n\n                    case 5:\n                      return [2\n                      /*return*/\n                      ];\n                  }\n                });\n              });\n            };\n\n            if (!(decodedTx.data.length >= 10)) return [3\n            /*break*/\n            , 18];\n            selector = decodedTx.data.substring(0, 10);\n            return [4\n            /*yield*/\n            , loadNftPlugin(decodedTx.to, selector, chainIdTruncated, this.loadConfig)];\n\n          case 1:\n            nftPluginPayload = _b.sent();\n            if (!nftPluginPayload) return [3\n            /*break*/\n            , 3];\n            return [4\n            /*yield*/\n            , setPlugin(this.transport, nftPluginPayload)];\n\n          case 2:\n            _b.sent();\n\n            return [3\n            /*break*/\n            , 16];\n\n          case 3:\n            return [4\n            /*yield*/\n            , loadInfosForContractMethod(decodedTx.to, selector, chainIdTruncated, this.loadConfig)];\n\n          case 4:\n            infos = _b.sent();\n            if (!infos) return [3\n            /*break*/\n            , 15];\n            plugin = infos.plugin, payload = infos.payload, signature = infos.signature, erc20OfInterest = infos.erc20OfInterest, abi = infos.abi;\n            if (!plugin) return [3\n            /*break*/\n            , 6];\n            log(\"ethereum\", \"loading plugin for \" + selector);\n            return [4\n            /*yield*/\n            , setExternalPlugin(this.transport, payload, signature)];\n\n          case 5:\n            _b.sent();\n\n            _b.label = 6;\n\n          case 6:\n            if (!(erc20OfInterest && erc20OfInterest.length && abi)) return [3\n            /*break*/\n            , 14];\n            contract = new ethers.utils.Interface(abi);\n            args = contract.parseTransaction(decodedTx).args;\n            _b.label = 7;\n\n          case 7:\n            _b.trys.push([7, 12, 13, 14]);\n\n            erc20OfInterest_1 = __values(erc20OfInterest), erc20OfInterest_1_1 = erc20OfInterest_1.next();\n            _b.label = 8;\n\n          case 8:\n            if (!!erc20OfInterest_1_1.done) return [3\n            /*break*/\n            , 11];\n            path = erc20OfInterest_1_1.value;\n            address = path.split(\".\").reduce(function (value, seg) {\n              if (seg === \"-1\" && Array.isArray(value)) {\n                return value[value.length - 1];\n              }\n\n              return value[seg];\n            }, args);\n            return [4\n            /*yield*/\n            , provideForContract(address)];\n\n          case 9:\n            _b.sent();\n\n            _b.label = 10;\n\n          case 10:\n            erc20OfInterest_1_1 = erc20OfInterest_1.next();\n            return [3\n            /*break*/\n            , 8];\n\n          case 11:\n            return [3\n            /*break*/\n            , 14];\n\n          case 12:\n            e_1_1 = _b.sent();\n            e_1 = {\n              error: e_1_1\n            };\n            return [3\n            /*break*/\n            , 14];\n\n          case 13:\n            try {\n              if (erc20OfInterest_1_1 && !erc20OfInterest_1_1.done && (_a = erc20OfInterest_1[\"return\"])) _a.call(erc20OfInterest_1);\n            } finally {\n              if (e_1) throw e_1.error;\n            }\n\n            return [7\n            /*endfinally*/\n            ];\n\n          case 14:\n            return [3\n            /*break*/\n            , 16];\n\n          case 15:\n            log(\"ethereum\", \"no infos for selector \" + selector);\n            _b.label = 16;\n\n          case 16:\n            return [4\n            /*yield*/\n            , provideForContract(decodedTx.to)];\n\n          case 17:\n            _b.sent();\n\n            _b.label = 18;\n\n          case 18:\n            return [2\n            /*return*/\n            , foreach(toSend, function (data, i) {\n              return _this.transport.send(0xe0, 0x04, i === 0 ? 0x00 : 0x80, 0x00, data).then(function (apduResponse) {\n                response = apduResponse;\n              });\n            }).then(function () {\n              var response_byte = response.slice(0, 1)[0];\n              var v = \"\";\n\n              if (chainId.times(2).plus(35).plus(1).isGreaterThan(255)) {\n                var oneByteChainId = (chainIdTruncated * 2 + 35) % 256;\n                var ecc_parity = Math.abs(response_byte - oneByteChainId);\n\n                if (txType != null) {\n                  // For EIP2930 and EIP1559 tx, v is simply the parity.\n                  v = ecc_parity % 2 == 1 ? \"00\" : \"01\";\n                } else {\n                  // Legacy type transaction with a big chain ID\n                  v = chainId.times(2).plus(35).plus(ecc_parity).toString(16);\n                }\n              } else {\n                v = response_byte.toString(16);\n              } // Make sure v has is prefixed with a 0 if its length is odd (\"1\" -> \"01\").\n\n\n              if (v.length % 2 == 1) {\n                v = \"0\" + v;\n              }\n\n              var r = response.slice(1, 1 + 32).toString(\"hex\");\n              var s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n              return {\n                v: v,\n                r: r,\n                s: s\n              };\n            }, function (e) {\n              throw remapTransactionRelatedErrors(e);\n            })];\n        }\n      });\n    });\n  };\n  /**\n   */\n\n\n  Eth.prototype.getAppConfiguration = function () {\n    return this.transport.send(0xe0, 0x06, 0x00, 0x00).then(function (response) {\n      return {\n        arbitraryDataEnabled: response[0] & 0x01,\n        erc20ProvisioningNecessary: response[0] & 0x02,\n        starkEnabled: response[0] & 0x04,\n        starkv2Supported: response[0] & 0x08,\n        version: \"\" + response[1] + \".\" + response[2] + \".\" + response[3]\n      };\n    });\n  };\n  /**\n  * You can sign a message according to eth_sign RPC call and retrieve v, r, s given the message and the BIP 32 path of the account to sign.\n  * @example\n  eth.signPersonalMessage(\"44'/60'/0'/0/0\", Buffer.from(\"test\").toString(\"hex\")).then(result => {\n  var v = result['v'] - 27;\n  v = v.toString(16);\n  if (v.length < 2) {\n    v = \"0\" + v;\n  }\n  console.log(\"Signature 0x\" + result['r'] + result['s'] + v);\n  })\n   */\n\n\n  Eth.prototype.signPersonalMessage = function (path, messageHex) {\n    var _this = this;\n\n    var paths = splitPath(path);\n    var offset = 0;\n    var message = Buffer.from(messageHex, \"hex\");\n    var toSend = [];\n    var response;\n\n    var _loop_2 = function () {\n      var maxChunkSize = offset === 0 ? 150 - 1 - paths.length * 4 - 4 : 150;\n      var chunkSize = offset + maxChunkSize > message.length ? message.length - offset : maxChunkSize;\n      var buffer = Buffer.alloc(offset === 0 ? 1 + paths.length * 4 + 4 + chunkSize : chunkSize);\n\n      if (offset === 0) {\n        buffer[0] = paths.length;\n        paths.forEach(function (element, index) {\n          buffer.writeUInt32BE(element, 1 + 4 * index);\n        });\n        buffer.writeUInt32BE(message.length, 1 + 4 * paths.length);\n        message.copy(buffer, 1 + 4 * paths.length + 4, offset, offset + chunkSize);\n      } else {\n        message.copy(buffer, 0, offset, offset + chunkSize);\n      }\n\n      toSend.push(buffer);\n      offset += chunkSize;\n    };\n\n    while (offset !== message.length) {\n      _loop_2();\n    }\n\n    return foreach(toSend, function (data, i) {\n      return _this.transport.send(0xe0, 0x08, i === 0 ? 0x00 : 0x80, 0x00, data).then(function (apduResponse) {\n        response = apduResponse;\n      });\n    }).then(function () {\n      var v = response[0];\n      var r = response.slice(1, 1 + 32).toString(\"hex\");\n      var s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n      return {\n        v: v,\n        r: r,\n        s: s\n      };\n    });\n  };\n  /**\n  * Sign a prepared message following web3.eth.signTypedData specification. The host computes the domain separator and hashStruct(message)\n  * @example\n  eth.signEIP712HashedMessage(\"44'/60'/0'/0/0\", Buffer.from(\"0101010101010101010101010101010101010101010101010101010101010101\").toString(\"hex\"), Buffer.from(\"0202020202020202020202020202020202020202020202020202020202020202\").toString(\"hex\")).then(result => {\n  var v = result['v'] - 27;\n  v = v.toString(16);\n  if (v.length < 2) {\n    v = \"0\" + v;\n  }\n  console.log(\"Signature 0x\" + result['r'] + result['s'] + v);\n  })\n   */\n\n\n  Eth.prototype.signEIP712HashedMessage = function (path, domainSeparatorHex, hashStructMessageHex) {\n    var domainSeparator = hexBuffer(domainSeparatorHex);\n    var hashStruct = hexBuffer(hashStructMessageHex);\n    var paths = splitPath(path);\n    var buffer = Buffer.alloc(1 + paths.length * 4 + 32 + 32, 0);\n    var offset = 0;\n    buffer[0] = paths.length;\n    paths.forEach(function (element, index) {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    offset = 1 + 4 * paths.length;\n    domainSeparator.copy(buffer, offset);\n    offset += 32;\n    hashStruct.copy(buffer, offset);\n    return this.transport.send(0xe0, 0x0c, 0x00, 0x00, buffer).then(function (response) {\n      var v = response[0];\n      var r = response.slice(1, 1 + 32).toString(\"hex\");\n      var s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n      return {\n        v: v,\n        r: r,\n        s: s\n      };\n    });\n  };\n  /**\n   * get Stark public key for a given BIP 32 path.\n   * @param path a path in BIP 32 format\n   * @option boolDisplay optionally enable or not the display\n   * @return the Stark public key\n   */\n\n\n  Eth.prototype.starkGetPublicKey = function (path, boolDisplay) {\n    var paths = splitPath(path);\n    var buffer = Buffer.alloc(1 + paths.length * 4);\n    buffer[0] = paths.length;\n    paths.forEach(function (element, index) {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    return this.transport.send(0xf0, 0x02, boolDisplay ? 0x01 : 0x00, 0x00, buffer).then(function (response) {\n      return response.slice(0, response.length - 2);\n    });\n  };\n  /**\n   * sign a Stark order\n   * @param path a path in BIP 32 format\n   * @option sourceTokenAddress contract address of the source token (not present for ETH)\n   * @param sourceQuantization quantization used for the source token\n   * @option destinationTokenAddress contract address of the destination token (not present for ETH)\n   * @param destinationQuantization quantization used for the destination token\n   * @param sourceVault ID of the source vault\n   * @param destinationVault ID of the destination vault\n   * @param amountSell amount to sell\n   * @param amountBuy amount to buy\n   * @param nonce transaction nonce\n   * @param timestamp transaction validity timestamp\n   * @return the signature\n   */\n\n\n  Eth.prototype.starkSignOrder = function (path, sourceTokenAddress, sourceQuantization, destinationTokenAddress, destinationQuantization, sourceVault, destinationVault, amountSell, amountBuy, nonce, timestamp) {\n    var sourceTokenAddressHex = maybeHexBuffer(sourceTokenAddress);\n    var destinationTokenAddressHex = maybeHexBuffer(destinationTokenAddress);\n    var paths = splitPath(path);\n    var buffer = Buffer.alloc(1 + paths.length * 4 + 20 + 32 + 20 + 32 + 4 + 4 + 8 + 8 + 4 + 4, 0);\n    var offset = 0;\n    buffer[0] = paths.length;\n    paths.forEach(function (element, index) {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    offset = 1 + 4 * paths.length;\n\n    if (sourceTokenAddressHex) {\n      sourceTokenAddressHex.copy(buffer, offset);\n    }\n\n    offset += 20;\n    Buffer.from(sourceQuantization.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, offset);\n    offset += 32;\n\n    if (destinationTokenAddressHex) {\n      destinationTokenAddressHex.copy(buffer, offset);\n    }\n\n    offset += 20;\n    Buffer.from(destinationQuantization.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, offset);\n    offset += 32;\n    buffer.writeUInt32BE(sourceVault, offset);\n    offset += 4;\n    buffer.writeUInt32BE(destinationVault, offset);\n    offset += 4;\n    Buffer.from(amountSell.toString(16).padStart(16, \"0\"), \"hex\").copy(buffer, offset);\n    offset += 8;\n    Buffer.from(amountBuy.toString(16).padStart(16, \"0\"), \"hex\").copy(buffer, offset);\n    offset += 8;\n    buffer.writeUInt32BE(nonce, offset);\n    offset += 4;\n    buffer.writeUInt32BE(timestamp, offset);\n    return this.transport.send(0xf0, 0x04, 0x01, 0x00, buffer).then(function (response) {\n      var r = response.slice(1, 1 + 32).toString(\"hex\");\n      var s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n      return {\n        r: r,\n        s: s\n      };\n    });\n  };\n  /**\n   * sign a Stark order using the Starkex V2 protocol\n   * @param path a path in BIP 32 format\n   * @option sourceTokenAddress contract address of the source token (not present for ETH)\n   * @param sourceQuantizationType quantization type used for the source token\n   * @option sourceQuantization quantization used for the source token (not present for erc 721 or mintable erc 721)\n   * @option sourceMintableBlobOrTokenId mintable blob (mintable erc 20 / mintable erc 721) or token id (erc 721) associated to the source token\n   * @option destinationTokenAddress contract address of the destination token (not present for ETH)\n   * @param destinationQuantizationType quantization type used for the destination token\n   * @option destinationQuantization quantization used for the destination token (not present for erc 721 or mintable erc 721)\n   * @option destinationMintableBlobOrTokenId mintable blob (mintable erc 20 / mintable erc 721) or token id (erc 721) associated to the destination token\n   * @param sourceVault ID of the source vault\n   * @param destinationVault ID of the destination vault\n   * @param amountSell amount to sell\n   * @param amountBuy amount to buy\n   * @param nonce transaction nonce\n   * @param timestamp transaction validity timestamp\n   * @return the signature\n   */\n\n\n  Eth.prototype.starkSignOrder_v2 = function (path, sourceTokenAddress, sourceQuantizationType, sourceQuantization, sourceMintableBlobOrTokenId, destinationTokenAddress, destinationQuantizationType, destinationQuantization, destinationMintableBlobOrTokenId, sourceVault, destinationVault, amountSell, amountBuy, nonce, timestamp) {\n    var sourceTokenAddressHex = maybeHexBuffer(sourceTokenAddress);\n    var destinationTokenAddressHex = maybeHexBuffer(destinationTokenAddress);\n\n    if (!(sourceQuantizationType in starkQuantizationTypeMap)) {\n      throw new Error(\"eth.starkSignOrderv2 invalid source quantization type=\" + sourceQuantizationType);\n    }\n\n    if (!(destinationQuantizationType in starkQuantizationTypeMap)) {\n      throw new Error(\"eth.starkSignOrderv2 invalid destination quantization type=\" + destinationQuantizationType);\n    }\n\n    var paths = splitPath(path);\n    var buffer = Buffer.alloc(1 + paths.length * 4 + 1 + 20 + 32 + 32 + 1 + 20 + 32 + 32 + 4 + 4 + 8 + 8 + 4 + 4, 0);\n    var offset = 0;\n    buffer[0] = paths.length;\n    paths.forEach(function (element, index) {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    offset = 1 + 4 * paths.length;\n    buffer[offset] = starkQuantizationTypeMap[sourceQuantizationType];\n    offset++;\n\n    if (sourceTokenAddressHex) {\n      sourceTokenAddressHex.copy(buffer, offset);\n    }\n\n    offset += 20;\n\n    if (sourceQuantization) {\n      Buffer.from(sourceQuantization.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, offset);\n    }\n\n    offset += 32;\n\n    if (sourceMintableBlobOrTokenId) {\n      Buffer.from(sourceMintableBlobOrTokenId.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, offset);\n    }\n\n    offset += 32;\n    buffer[offset] = starkQuantizationTypeMap[destinationQuantizationType];\n    offset++;\n\n    if (destinationTokenAddressHex) {\n      destinationTokenAddressHex.copy(buffer, offset);\n    }\n\n    offset += 20;\n\n    if (destinationQuantization) {\n      Buffer.from(destinationQuantization.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, offset);\n    }\n\n    offset += 32;\n\n    if (destinationMintableBlobOrTokenId) {\n      Buffer.from(destinationMintableBlobOrTokenId.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, offset);\n    }\n\n    offset += 32;\n    buffer.writeUInt32BE(sourceVault, offset);\n    offset += 4;\n    buffer.writeUInt32BE(destinationVault, offset);\n    offset += 4;\n    Buffer.from(amountSell.toString(16).padStart(16, \"0\"), \"hex\").copy(buffer, offset);\n    offset += 8;\n    Buffer.from(amountBuy.toString(16).padStart(16, \"0\"), \"hex\").copy(buffer, offset);\n    offset += 8;\n    buffer.writeUInt32BE(nonce, offset);\n    offset += 4;\n    buffer.writeUInt32BE(timestamp, offset);\n    return this.transport.send(0xf0, 0x04, 0x03, 0x00, buffer).then(function (response) {\n      var r = response.slice(1, 1 + 32).toString(\"hex\");\n      var s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n      return {\n        r: r,\n        s: s\n      };\n    });\n  };\n  /**\n   * sign a Stark transfer\n   * @param path a path in BIP 32 format\n   * @option transferTokenAddress contract address of the token to be transferred (not present for ETH)\n   * @param transferQuantization quantization used for the token to be transferred\n   * @param targetPublicKey target Stark public key\n   * @param sourceVault ID of the source vault\n   * @param destinationVault ID of the destination vault\n   * @param amountTransfer amount to transfer\n   * @param nonce transaction nonce\n   * @param timestamp transaction validity timestamp\n   * @return the signature\n   */\n\n\n  Eth.prototype.starkSignTransfer = function (path, transferTokenAddress, transferQuantization, targetPublicKey, sourceVault, destinationVault, amountTransfer, nonce, timestamp) {\n    var transferTokenAddressHex = maybeHexBuffer(transferTokenAddress);\n    var targetPublicKeyHex = hexBuffer(targetPublicKey);\n    var paths = splitPath(path);\n    var buffer = Buffer.alloc(1 + paths.length * 4 + 20 + 32 + 32 + 4 + 4 + 8 + 4 + 4, 0);\n    var offset = 0;\n    buffer[0] = paths.length;\n    paths.forEach(function (element, index) {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    offset = 1 + 4 * paths.length;\n\n    if (transferTokenAddressHex) {\n      transferTokenAddressHex.copy(buffer, offset);\n    }\n\n    offset += 20;\n    Buffer.from(transferQuantization.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, offset);\n    offset += 32;\n    targetPublicKeyHex.copy(buffer, offset);\n    offset += 32;\n    buffer.writeUInt32BE(sourceVault, offset);\n    offset += 4;\n    buffer.writeUInt32BE(destinationVault, offset);\n    offset += 4;\n    Buffer.from(amountTransfer.toString(16).padStart(16, \"0\"), \"hex\").copy(buffer, offset);\n    offset += 8;\n    buffer.writeUInt32BE(nonce, offset);\n    offset += 4;\n    buffer.writeUInt32BE(timestamp, offset);\n    return this.transport.send(0xf0, 0x04, 0x02, 0x00, buffer).then(function (response) {\n      var r = response.slice(1, 1 + 32).toString(\"hex\");\n      var s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n      return {\n        r: r,\n        s: s\n      };\n    });\n  };\n  /**\n   * sign a Stark transfer or conditional transfer using the Starkex V2 protocol\n   * @param path a path in BIP 32 format\n   * @option transferTokenAddress contract address of the token to be transferred (not present for ETH)\n   * @param transferQuantizationType quantization type used for the token to be transferred\n   * @option transferQuantization quantization used for the token to be transferred (not present for erc 721 or mintable erc 721)\n   * @option transferMintableBlobOrTokenId mintable blob (mintable erc 20 / mintable erc 721) or token id (erc 721) associated to the token to be transferred\n   * @param targetPublicKey target Stark public key\n   * @param sourceVault ID of the source vault\n   * @param destinationVault ID of the destination vault\n   * @param amountTransfer amount to transfer\n   * @param nonce transaction nonce\n   * @param timestamp transaction validity timestamp\n   * @option conditionalTransferAddress onchain address of the condition for a conditional transfer\n   * @option conditionalTransferFact fact associated to the condition for a conditional transfer\n   * @return the signature\n   */\n\n\n  Eth.prototype.starkSignTransfer_v2 = function (path, transferTokenAddress, transferQuantizationType, transferQuantization, transferMintableBlobOrTokenId, targetPublicKey, sourceVault, destinationVault, amountTransfer, nonce, timestamp, conditionalTransferAddress, conditionalTransferFact) {\n    var transferTokenAddressHex = maybeHexBuffer(transferTokenAddress);\n    var targetPublicKeyHex = hexBuffer(targetPublicKey);\n    var conditionalTransferAddressHex = maybeHexBuffer(conditionalTransferAddress);\n\n    if (!(transferQuantizationType in starkQuantizationTypeMap)) {\n      throw new Error(\"eth.starkSignTransferv2 invalid quantization type=\" + transferQuantizationType);\n    }\n\n    var paths = splitPath(path);\n    var buffer = Buffer.alloc(1 + paths.length * 4 + 1 + 20 + 32 + 32 + 32 + 4 + 4 + 8 + 4 + 4 + (conditionalTransferAddressHex ? 32 + 20 : 0), 0);\n    var offset = 0;\n    buffer[0] = paths.length;\n    paths.forEach(function (element, index) {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    offset = 1 + 4 * paths.length;\n    buffer[offset] = starkQuantizationTypeMap[transferQuantizationType];\n    offset++;\n\n    if (transferTokenAddressHex) {\n      transferTokenAddressHex.copy(buffer, offset);\n    }\n\n    offset += 20;\n\n    if (transferQuantization) {\n      Buffer.from(transferQuantization.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, offset);\n    }\n\n    offset += 32;\n\n    if (transferMintableBlobOrTokenId) {\n      Buffer.from(transferMintableBlobOrTokenId.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, offset);\n    }\n\n    offset += 32;\n    targetPublicKeyHex.copy(buffer, offset);\n    offset += 32;\n    buffer.writeUInt32BE(sourceVault, offset);\n    offset += 4;\n    buffer.writeUInt32BE(destinationVault, offset);\n    offset += 4;\n    Buffer.from(amountTransfer.toString(16).padStart(16, \"0\"), \"hex\").copy(buffer, offset);\n    offset += 8;\n    buffer.writeUInt32BE(nonce, offset);\n    offset += 4;\n    buffer.writeUInt32BE(timestamp, offset);\n\n    if (conditionalTransferAddressHex && conditionalTransferFact) {\n      offset += 4;\n      Buffer.from(conditionalTransferFact.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, offset);\n      offset += 32;\n      conditionalTransferAddressHex.copy(buffer, offset);\n    }\n\n    return this.transport.send(0xf0, 0x04, conditionalTransferAddressHex ? 0x05 : 0x04, 0x00, buffer).then(function (response) {\n      var r = response.slice(1, 1 + 32).toString(\"hex\");\n      var s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n      return {\n        r: r,\n        s: s\n      };\n    });\n  };\n  /**\n   * provide quantization information before singing a deposit or withdrawal Stark powered contract call\n   *\n   * It shall be run following a provideERC20TokenInformation call for the given contract\n   *\n   * @param operationContract contract address of the token to be transferred (not present for ETH)\n   * @param operationQuantization quantization used for the token to be transferred\n   */\n\n\n  Eth.prototype.starkProvideQuantum = function (operationContract, operationQuantization) {\n    var operationContractHex = maybeHexBuffer(operationContract);\n    var buffer = Buffer.alloc(20 + 32, 0);\n\n    if (operationContractHex) {\n      operationContractHex.copy(buffer, 0);\n    }\n\n    Buffer.from(operationQuantization.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, 20);\n    return this.transport.send(0xf0, 0x08, 0x00, 0x00, buffer).then(function () {\n      return true;\n    }, function (e) {\n      if (e && e.statusCode === 0x6d00) {\n        // this case happen for ETH application versions not supporting Stark extensions\n        return false;\n      }\n\n      throw e;\n    });\n  };\n  /**\n   * provide quantization information before singing a deposit or withdrawal Stark powered contract call using the Starkex V2 protocol\n   *\n   * It shall be run following a provideERC20TokenInformation call for the given contract\n   *\n   * @param operationContract contract address of the token to be transferred (not present for ETH)\n   * @param operationQuantizationType quantization type of the token to be transferred\n   * @option operationQuantization quantization used for the token to be transferred (not present for erc 721 or mintable erc 721)\n   * @option operationMintableBlobOrTokenId mintable blob (mintable erc 20 / mintable erc 721) or token id (erc 721) of the token to be transferred\n   */\n\n\n  Eth.prototype.starkProvideQuantum_v2 = function (operationContract, operationQuantizationType, operationQuantization, operationMintableBlobOrTokenId) {\n    var operationContractHex = maybeHexBuffer(operationContract);\n\n    if (!(operationQuantizationType in starkQuantizationTypeMap)) {\n      throw new Error(\"eth.starkProvideQuantumV2 invalid quantization type=\" + operationQuantizationType);\n    }\n\n    var buffer = Buffer.alloc(20 + 32 + 32, 0);\n    var offset = 0;\n\n    if (operationContractHex) {\n      operationContractHex.copy(buffer, offset);\n    }\n\n    offset += 20;\n\n    if (operationQuantization) {\n      Buffer.from(operationQuantization.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, offset);\n    }\n\n    offset += 32;\n\n    if (operationMintableBlobOrTokenId) {\n      Buffer.from(operationMintableBlobOrTokenId.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, offset);\n    }\n\n    return this.transport.send(0xf0, 0x08, starkQuantizationTypeMap[operationQuantizationType], 0x00, buffer).then(function () {\n      return true;\n    }, function (e) {\n      if (e && e.statusCode === 0x6d00) {\n        // this case happen for ETH application versions not supporting Stark extensions\n        return false;\n      }\n\n      throw e;\n    });\n  };\n  /**\n   * sign the given hash over the Stark curve\n   * It is intended for speed of execution in case an unknown Stark model is pushed and should be avoided as much as possible.\n   * @param path a path in BIP 32 format\n   * @param hash hexadecimal hash to sign\n   * @return the signature\n   */\n\n\n  Eth.prototype.starkUnsafeSign = function (path, hash) {\n    var hashHex = hexBuffer(hash);\n    var paths = splitPath(path);\n    var buffer = Buffer.alloc(1 + paths.length * 4 + 32);\n    var offset = 0;\n    buffer[0] = paths.length;\n    paths.forEach(function (element, index) {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    offset = 1 + 4 * paths.length;\n    hashHex.copy(buffer, offset);\n    return this.transport.send(0xf0, 0x0a, 0x00, 0x00, buffer).then(function (response) {\n      var r = response.slice(1, 1 + 32).toString(\"hex\");\n      var s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n      return {\n        r: r,\n        s: s\n      };\n    });\n  };\n  /**\n   * get an Ethereum 2 BLS-12 381 public key for a given BIP 32 path.\n   * @param path a path in BIP 32 format\n   * @option boolDisplay optionally enable or not the display\n   * @return an object with a publicKey\n   * @example\n   * eth.eth2GetPublicKey(\"12381/3600/0/0\").then(o => o.publicKey)\n   */\n\n\n  Eth.prototype.eth2GetPublicKey = function (path, boolDisplay) {\n    var paths = splitPath(path);\n    var buffer = Buffer.alloc(1 + paths.length * 4);\n    buffer[0] = paths.length;\n    paths.forEach(function (element, index) {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    return this.transport.send(0xe0, 0x0e, boolDisplay ? 0x01 : 0x00, 0x00, buffer).then(function (response) {\n      return {\n        publicKey: response.slice(0, -2).toString(\"hex\")\n      };\n    });\n  };\n  /**\n   * Set the index of a Withdrawal key used as withdrawal credentials in an ETH 2 deposit contract call signature\n   *\n   * It shall be run before the ETH 2 deposit transaction is signed. If not called, the index is set to 0\n   *\n   * @param withdrawalIndex index path in the EIP 2334 path m/12381/3600/withdrawalIndex/0\n   * @return True if the method was executed successfully\n   */\n\n\n  Eth.prototype.eth2SetWithdrawalIndex = function (withdrawalIndex) {\n    var buffer = Buffer.alloc(4, 0);\n    buffer.writeUInt32BE(withdrawalIndex, 0);\n    return this.transport.send(0xe0, 0x10, 0x00, 0x00, buffer).then(function () {\n      return true;\n    }, function (e) {\n      if (e && e.statusCode === 0x6d00) {\n        // this case happen for ETH application versions not supporting ETH 2\n        return false;\n      }\n\n      throw e;\n    });\n  };\n  /**\n   * Set the name of the external plugin that should be used to parse the next transaction\n   *\n   * @param pluginName string containing the name of the plugin, must have length between 1 and 30 bytes\n   * @return True if the method was executed successfully\n   */\n\n\n  Eth.prototype.setExternalPlugin = function (pluginName, contractAddress, selector) {\n    return setExternalPlugin(this.transport, pluginName, selector);\n  };\n  /**\n   * Set the plugin (internal or external) that should be used to parse the next transaction\n   *\n   * @param data string containing the payload and signature that will be parsed and verified by the device.\n   * @return True if the method was executed successfully\n   */\n\n\n  Eth.prototype.setPlugin = function (data) {\n    return setPlugin(this.transport, data);\n  };\n\n  return Eth;\n}();\n\nexport default Eth; // internal helpers\n\nfunction provideERC20TokenInformation(transport, data) {\n  return transport.send(0xe0, 0x0a, 0x00, 0x00, data).then(function () {\n    return true;\n  }, function (e) {\n    if (e && e.statusCode === 0x6d00) {\n      // this case happen for older version of ETH app, since older app version had the ERC20 data hardcoded, it's fine to assume it worked.\n      // we return a flag to know if the call was effective or not\n      return false;\n    }\n\n    throw e;\n  });\n}\n\nfunction provideNFTInformation(transport, data) {\n  return transport.send(0xe0, 0x14, 0x00, 0x00, data).then(function () {\n    return true;\n  }, function (e) {\n    if (e && e.statusCode === 0x6a80) {\n      // some issue with providing the data\n      return false;\n    }\n\n    if (e && e.statusCode === 0x6d00) {\n      // ignore older version of ETH app\n      return false;\n    }\n\n    throw e;\n  });\n}\n\nfunction setExternalPlugin(transport, payload, signature) {\n  var payloadBuffer = Buffer.from(payload, \"hex\");\n  var signatureBuffer = Buffer.from(signature, \"hex\");\n  var buffer = Buffer.concat([payloadBuffer, signatureBuffer]);\n  return transport.send(0xe0, 0x12, 0x00, 0x00, buffer).then(function () {\n    return true;\n  }, function (e) {\n    if (e && e.statusCode === 0x6a80) {\n      // this case happen when the plugin name is too short or too long\n      return false;\n    } else if (e && e.statusCode === 0x6984) {\n      // this case happen when the plugin requested is not installed on the device\n      return false;\n    } else if (e && e.statusCode === 0x6d00) {\n      // this case happen for older version of ETH app\n      return false;\n    }\n\n    throw e;\n  });\n}\n\nfunction setPlugin(transport, data) {\n  var buffer = Buffer.from(data, \"hex\");\n  return transport.send(0xe0, 0x16, 0x00, 0x00, buffer).then(function () {\n    return true;\n  }, function (e) {\n    if (e && e.statusCode === 0x6a80) {\n      // this case happen when the plugin name is too short or too long\n      return false;\n    } else if (e && e.statusCode === 0x6984) {\n      // this case happen when the plugin requested is not installed on the device\n      return false;\n    } else if (e && e.statusCode === 0x6d00) {\n      // this case happen for older version of ETH app\n      return false;\n    }\n\n    throw e;\n  });\n}","map":{"version":3,"sources":["../src/Eth.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n/********************************************************************************\n *   Ledger Node JS API\n *   (c) 2016-2017 Ledger\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n// FIXME drop:\nimport { splitPath, foreach } from \"./utils\";\nimport { log } from \"@ledgerhq/logs\";\nimport { EthAppPleaseEnableContractData } from \"@ledgerhq/errors\";\nimport { BigNumber } from \"bignumber.js\";\nimport { ethers } from \"ethers\";\nimport { byContractAddressAndChainId } from \"./erc20\";\nimport { loadInfosForContractMethod } from \"./contracts\";\nimport { getNFTInfo, loadNftPlugin } from \"./nfts\";\nvar starkQuantizationTypeMap = {\n    eth: 1,\n    erc20: 2,\n    erc721: 3,\n    erc20mintable: 4,\n    erc721mintable: 5\n};\nfunction hexBuffer(str) {\n    return Buffer.from(str.startsWith(\"0x\") ? str.slice(2) : str, \"hex\");\n}\nfunction maybeHexBuffer(str) {\n    if (!str)\n        return null;\n    return hexBuffer(str);\n}\nvar remapTransactionRelatedErrors = function (e) {\n    if (e && e.statusCode === 0x6a80) {\n        return new EthAppPleaseEnableContractData(\"Please enable Blind signing or Contract data in the Ethereum app Settings\");\n    }\n    return e;\n};\n/**\n * Ethereum API\n *\n * @example\n * import Eth from \"@ledgerhq/hw-app-eth\";\n * const eth = new Eth(transport)\n */\nvar Eth = /** @class */ (function () {\n    function Eth(transport, scrambleKey, loadConfig) {\n        if (scrambleKey === void 0) { scrambleKey = \"w0w\"; }\n        if (loadConfig === void 0) { loadConfig = {}; }\n        this.transport = transport;\n        this.loadConfig = loadConfig;\n        transport.decorateAppAPIMethods(this, [\n            \"getAddress\",\n            \"provideERC20TokenInformation\",\n            \"signTransaction\",\n            \"signPersonalMessage\",\n            \"getAppConfiguration\",\n            \"signEIP712HashedMessage\",\n            \"starkGetPublicKey\",\n            \"starkSignOrder\",\n            \"starkSignOrder_v2\",\n            \"starkSignTransfer\",\n            \"starkSignTransfer_v2\",\n            \"starkProvideQuantum\",\n            \"starkProvideQuantum_v2\",\n            \"starkUnsafeSign\",\n            \"eth2GetPublicKey\",\n            \"eth2SetWithdrawalIndex\",\n            \"setExternalPlugin\",\n            \"setPlugin\",\n        ], scrambleKey);\n    }\n    Eth.prototype.setLoadConfig = function (loadConfig) {\n        this.loadConfig = loadConfig;\n    };\n    /**\n     * get Ethereum address for a given BIP 32 path.\n     * @param path a path in BIP 32 format\n     * @option boolDisplay optionally enable or not the display\n     * @option boolChaincode optionally enable or not the chaincode request\n     * @return an object with a publicKey, address and (optionally) chainCode\n     * @example\n     * eth.getAddress(\"44'/60'/0'/0/0\").then(o => o.address)\n     */\n    Eth.prototype.getAddress = function (path, boolDisplay, boolChaincode) {\n        var paths = splitPath(path);\n        var buffer = Buffer.alloc(1 + paths.length * 4);\n        buffer[0] = paths.length;\n        paths.forEach(function (element, index) {\n            buffer.writeUInt32BE(element, 1 + 4 * index);\n        });\n        return this.transport\n            .send(0xe0, 0x02, boolDisplay ? 0x01 : 0x00, boolChaincode ? 0x01 : 0x00, buffer)\n            .then(function (response) {\n            var publicKeyLength = response[0];\n            var addressLength = response[1 + publicKeyLength];\n            return {\n                publicKey: response.slice(1, 1 + publicKeyLength).toString(\"hex\"),\n                address: \"0x\" +\n                    response\n                        .slice(1 + publicKeyLength + 1, 1 + publicKeyLength + 1 + addressLength)\n                        .toString(\"ascii\"),\n                chainCode: boolChaincode\n                    ? response\n                        .slice(1 + publicKeyLength + 1 + addressLength, 1 + publicKeyLength + 1 + addressLength + 32)\n                        .toString(\"hex\")\n                    : undefined\n            };\n        });\n    };\n    /**\n     * This commands provides a trusted description of an ERC 20 token\n     * to associate a contract address with a ticker and number of decimals.\n     *\n     * It shall be run immediately before performing a transaction involving a contract\n     * calling this contract address to display the proper token information to the user if necessary.\n     *\n     * @param {*} info: a blob from \"erc20.js\" utilities that contains all token information.\n     *\n     * @example\n     * import { byContractAddressAndChainId } from \"@ledgerhq/hw-app-eth/erc20\"\n     * const zrxInfo = byContractAddressAndChainId(\"0xe41d2489571d322189246dafa5ebde1f4699f498\", chainId)\n     * if (zrxInfo) await appEth.provideERC20TokenInformation(zrxInfo)\n     * const signed = await appEth.signTransaction(path, rawTxHex)\n     */\n    Eth.prototype.provideERC20TokenInformation = function (_a) {\n        var data = _a.data;\n        return provideERC20TokenInformation(this.transport, data);\n    };\n    /**\n     * You can sign a transaction and retrieve v, r, s given the raw transaction and the BIP 32 path of the account to sign\n     * @example\n     eth.signTransaction(\"44'/60'/0'/0/0\", \"e8018504e3b292008252089428ee52a8f3d6e5d15f8b131996950d7f296c7952872bd72a2487400080\").then(result => ...)\n     */\n    Eth.prototype.signTransaction = function (path, rawTxHex) {\n        return __awaiter(this, void 0, void 0, function () {\n            var paths, offset, rawTx, VALID_TYPES, txType, rlpData, toSend, response, rlpTx, vrsOffset, chainId, chainIdTruncated, rlpDecoded, decodedTx, rlpVrs, sizeOfListLen, chainIdSrc, chainIdTruncatedBuf, _loop_1, provideForContract, selector, nftPluginPayload, infos, plugin, payload, signature, erc20OfInterest, abi, contract, args, erc20OfInterest_1, erc20OfInterest_1_1, address, e_1_1;\n            var e_1, _a;\n            var _this = this;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        paths = splitPath(path);\n                        offset = 0;\n                        rawTx = Buffer.from(rawTxHex, \"hex\");\n                        VALID_TYPES = [1, 2];\n                        txType = VALID_TYPES.includes(rawTx[0]) ? rawTx[0] : null;\n                        rlpData = txType === null ? rawTx : rawTx.slice(1, rawTxHex.length);\n                        toSend = [];\n                        rlpTx = ethers.utils.RLP.decode(rlpData).map(function (hex) {\n                            return Buffer.from(hex.slice(2), \"hex\");\n                        });\n                        vrsOffset = 0;\n                        chainId = new BigNumber(0);\n                        chainIdTruncated = 0;\n                        rlpDecoded = ethers.utils.RLP.decode(rlpData);\n                        if (txType === 2) {\n                            // EIP1559\n                            decodedTx = {\n                                data: rlpDecoded[7],\n                                to: rlpDecoded[5],\n                                chainId: rlpTx[0]\n                            };\n                        }\n                        else if (txType === 1) {\n                            // EIP2930\n                            decodedTx = {\n                                data: rlpDecoded[6],\n                                to: rlpDecoded[4],\n                                chainId: rlpTx[0]\n                            };\n                        }\n                        else {\n                            // Legacy tx\n                            decodedTx = {\n                                data: rlpDecoded[5],\n                                to: rlpDecoded[3],\n                                // Default to 1 for non EIP 155 txs\n                                chainId: rlpTx.length > 6 ? rlpTx[6] : Buffer.from(\"0x01\", \"hex\")\n                            };\n                        }\n                        if (txType === null && rlpTx.length > 6) {\n                            rlpVrs = Buffer.from(ethers.utils.RLP.encode(rlpTx.slice(-3)).slice(2), \"hex\");\n                            vrsOffset = rawTx.length - (rlpVrs.length - 1);\n                            // First byte > 0xf7 means the length of the list length doesn't fit in a single byte.\n                            if (rlpVrs[0] > 0xf7) {\n                                // Increment vrsOffset to account for that extra byte.\n                                vrsOffset++;\n                                sizeOfListLen = rlpVrs[0] - 0xf7;\n                                // Increase rlpOffset by the size of the list length.\n                                vrsOffset += sizeOfListLen - 1;\n                            }\n                        }\n                        chainIdSrc = decodedTx.chainId;\n                        if (chainIdSrc) {\n                            // Using BigNumber because chainID could be any uint256.\n                            chainId = new BigNumber(chainIdSrc.toString(\"hex\"), 16);\n                            chainIdTruncatedBuf = Buffer.alloc(4);\n                            if (chainIdSrc.length > 4) {\n                                chainIdSrc.copy(chainIdTruncatedBuf);\n                            }\n                            else {\n                                chainIdSrc.copy(chainIdTruncatedBuf, 4 - chainIdSrc.length);\n                            }\n                            chainIdTruncated = chainIdTruncatedBuf.readUInt32BE(0);\n                        }\n                        _loop_1 = function () {\n                            var maxChunkSize = offset === 0 ? 150 - 1 - paths.length * 4 : 150;\n                            var chunkSize = offset + maxChunkSize > rawTx.length\n                                ? rawTx.length - offset\n                                : maxChunkSize;\n                            if (vrsOffset != 0 && offset + chunkSize >= vrsOffset) {\n                                // Make sure that the chunk doesn't end right on the EIP 155 marker if set\n                                chunkSize = rawTx.length - offset;\n                            }\n                            var buffer = Buffer.alloc(offset === 0 ? 1 + paths.length * 4 + chunkSize : chunkSize);\n                            if (offset === 0) {\n                                buffer[0] = paths.length;\n                                paths.forEach(function (element, index) {\n                                    buffer.writeUInt32BE(element, 1 + 4 * index);\n                                });\n                                rawTx.copy(buffer, 1 + 4 * paths.length, offset, offset + chunkSize);\n                            }\n                            else {\n                                rawTx.copy(buffer, 0, offset, offset + chunkSize);\n                            }\n                            toSend.push(buffer);\n                            offset += chunkSize;\n                        };\n                        while (offset !== rawTx.length) {\n                            _loop_1();\n                        }\n                        provideForContract = function (address) { return __awaiter(_this, void 0, void 0, function () {\n                            var nftInfo, erc20Info;\n                            return __generator(this, function (_a) {\n                                switch (_a.label) {\n                                    case 0: return [4 /*yield*/, getNFTInfo(address, chainIdTruncated, this.loadConfig)];\n                                    case 1:\n                                        nftInfo = _a.sent();\n                                        if (!nftInfo) return [3 /*break*/, 3];\n                                        log(\"ethereum\", \"loading nft info for \" +\n                                            nftInfo.contractAddress +\n                                            \" (\" +\n                                            nftInfo.collectionName +\n                                            \")\");\n                                        return [4 /*yield*/, provideNFTInformation(this.transport, nftInfo.data)];\n                                    case 2:\n                                        _a.sent();\n                                        return [3 /*break*/, 5];\n                                    case 3:\n                                        erc20Info = byContractAddressAndChainId(address, chainIdTruncated);\n                                        if (!erc20Info) return [3 /*break*/, 5];\n                                        log(\"ethereum\", \"loading erc20token info for \" +\n                                            erc20Info.contractAddress +\n                                            \" (\" +\n                                            erc20Info.ticker +\n                                            \")\");\n                                        return [4 /*yield*/, provideERC20TokenInformation(this.transport, erc20Info.data)];\n                                    case 4:\n                                        _a.sent();\n                                        _a.label = 5;\n                                    case 5: return [2 /*return*/];\n                                }\n                            });\n                        }); };\n                        if (!(decodedTx.data.length >= 10)) return [3 /*break*/, 18];\n                        selector = decodedTx.data.substring(0, 10);\n                        return [4 /*yield*/, loadNftPlugin(decodedTx.to, selector, chainIdTruncated, this.loadConfig)];\n                    case 1:\n                        nftPluginPayload = _b.sent();\n                        if (!nftPluginPayload) return [3 /*break*/, 3];\n                        return [4 /*yield*/, setPlugin(this.transport, nftPluginPayload)];\n                    case 2:\n                        _b.sent();\n                        return [3 /*break*/, 16];\n                    case 3: return [4 /*yield*/, loadInfosForContractMethod(decodedTx.to, selector, chainIdTruncated, this.loadConfig)];\n                    case 4:\n                        infos = _b.sent();\n                        if (!infos) return [3 /*break*/, 15];\n                        plugin = infos.plugin, payload = infos.payload, signature = infos.signature, erc20OfInterest = infos.erc20OfInterest, abi = infos.abi;\n                        if (!plugin) return [3 /*break*/, 6];\n                        log(\"ethereum\", \"loading plugin for \" + selector);\n                        return [4 /*yield*/, setExternalPlugin(this.transport, payload, signature)];\n                    case 5:\n                        _b.sent();\n                        _b.label = 6;\n                    case 6:\n                        if (!(erc20OfInterest && erc20OfInterest.length && abi)) return [3 /*break*/, 14];\n                        contract = new ethers.utils.Interface(abi);\n                        args = contract.parseTransaction(decodedTx).args;\n                        _b.label = 7;\n                    case 7:\n                        _b.trys.push([7, 12, 13, 14]);\n                        erc20OfInterest_1 = __values(erc20OfInterest), erc20OfInterest_1_1 = erc20OfInterest_1.next();\n                        _b.label = 8;\n                    case 8:\n                        if (!!erc20OfInterest_1_1.done) return [3 /*break*/, 11];\n                        path = erc20OfInterest_1_1.value;\n                        address = path.split(\".\").reduce(function (value, seg) {\n                            if (seg === \"-1\" && Array.isArray(value)) {\n                                return value[value.length - 1];\n                            }\n                            return value[seg];\n                        }, args);\n                        return [4 /*yield*/, provideForContract(address)];\n                    case 9:\n                        _b.sent();\n                        _b.label = 10;\n                    case 10:\n                        erc20OfInterest_1_1 = erc20OfInterest_1.next();\n                        return [3 /*break*/, 8];\n                    case 11: return [3 /*break*/, 14];\n                    case 12:\n                        e_1_1 = _b.sent();\n                        e_1 = { error: e_1_1 };\n                        return [3 /*break*/, 14];\n                    case 13:\n                        try {\n                            if (erc20OfInterest_1_1 && !erc20OfInterest_1_1.done && (_a = erc20OfInterest_1[\"return\"])) _a.call(erc20OfInterest_1);\n                        }\n                        finally { if (e_1) throw e_1.error; }\n                        return [7 /*endfinally*/];\n                    case 14: return [3 /*break*/, 16];\n                    case 15:\n                        log(\"ethereum\", \"no infos for selector \" + selector);\n                        _b.label = 16;\n                    case 16: return [4 /*yield*/, provideForContract(decodedTx.to)];\n                    case 17:\n                        _b.sent();\n                        _b.label = 18;\n                    case 18: return [2 /*return*/, foreach(toSend, function (data, i) {\n                            return _this.transport\n                                .send(0xe0, 0x04, i === 0 ? 0x00 : 0x80, 0x00, data)\n                                .then(function (apduResponse) {\n                                response = apduResponse;\n                            });\n                        }).then(function () {\n                            var response_byte = response.slice(0, 1)[0];\n                            var v = \"\";\n                            if (chainId.times(2).plus(35).plus(1).isGreaterThan(255)) {\n                                var oneByteChainId = (chainIdTruncated * 2 + 35) % 256;\n                                var ecc_parity = Math.abs(response_byte - oneByteChainId);\n                                if (txType != null) {\n                                    // For EIP2930 and EIP1559 tx, v is simply the parity.\n                                    v = ecc_parity % 2 == 1 ? \"00\" : \"01\";\n                                }\n                                else {\n                                    // Legacy type transaction with a big chain ID\n                                    v = chainId.times(2).plus(35).plus(ecc_parity).toString(16);\n                                }\n                            }\n                            else {\n                                v = response_byte.toString(16);\n                            }\n                            // Make sure v has is prefixed with a 0 if its length is odd (\"1\" -> \"01\").\n                            if (v.length % 2 == 1) {\n                                v = \"0\" + v;\n                            }\n                            var r = response.slice(1, 1 + 32).toString(\"hex\");\n                            var s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n                            return {\n                                v: v,\n                                r: r,\n                                s: s\n                            };\n                        }, function (e) {\n                            throw remapTransactionRelatedErrors(e);\n                        })];\n                }\n            });\n        });\n    };\n    /**\n     */\n    Eth.prototype.getAppConfiguration = function () {\n        return this.transport.send(0xe0, 0x06, 0x00, 0x00).then(function (response) {\n            return {\n                arbitraryDataEnabled: response[0] & 0x01,\n                erc20ProvisioningNecessary: response[0] & 0x02,\n                starkEnabled: response[0] & 0x04,\n                starkv2Supported: response[0] & 0x08,\n                version: \"\" + response[1] + \".\" + response[2] + \".\" + response[3]\n            };\n        });\n    };\n    /**\n    * You can sign a message according to eth_sign RPC call and retrieve v, r, s given the message and the BIP 32 path of the account to sign.\n    * @example\n    eth.signPersonalMessage(\"44'/60'/0'/0/0\", Buffer.from(\"test\").toString(\"hex\")).then(result => {\n    var v = result['v'] - 27;\n    v = v.toString(16);\n    if (v.length < 2) {\n      v = \"0\" + v;\n    }\n    console.log(\"Signature 0x\" + result['r'] + result['s'] + v);\n    })\n     */\n    Eth.prototype.signPersonalMessage = function (path, messageHex) {\n        var _this = this;\n        var paths = splitPath(path);\n        var offset = 0;\n        var message = Buffer.from(messageHex, \"hex\");\n        var toSend = [];\n        var response;\n        var _loop_2 = function () {\n            var maxChunkSize = offset === 0 ? 150 - 1 - paths.length * 4 - 4 : 150;\n            var chunkSize = offset + maxChunkSize > message.length\n                ? message.length - offset\n                : maxChunkSize;\n            var buffer = Buffer.alloc(offset === 0 ? 1 + paths.length * 4 + 4 + chunkSize : chunkSize);\n            if (offset === 0) {\n                buffer[0] = paths.length;\n                paths.forEach(function (element, index) {\n                    buffer.writeUInt32BE(element, 1 + 4 * index);\n                });\n                buffer.writeUInt32BE(message.length, 1 + 4 * paths.length);\n                message.copy(buffer, 1 + 4 * paths.length + 4, offset, offset + chunkSize);\n            }\n            else {\n                message.copy(buffer, 0, offset, offset + chunkSize);\n            }\n            toSend.push(buffer);\n            offset += chunkSize;\n        };\n        while (offset !== message.length) {\n            _loop_2();\n        }\n        return foreach(toSend, function (data, i) {\n            return _this.transport\n                .send(0xe0, 0x08, i === 0 ? 0x00 : 0x80, 0x00, data)\n                .then(function (apduResponse) {\n                response = apduResponse;\n            });\n        }).then(function () {\n            var v = response[0];\n            var r = response.slice(1, 1 + 32).toString(\"hex\");\n            var s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n            return {\n                v: v,\n                r: r,\n                s: s\n            };\n        });\n    };\n    /**\n    * Sign a prepared message following web3.eth.signTypedData specification. The host computes the domain separator and hashStruct(message)\n    * @example\n    eth.signEIP712HashedMessage(\"44'/60'/0'/0/0\", Buffer.from(\"0101010101010101010101010101010101010101010101010101010101010101\").toString(\"hex\"), Buffer.from(\"0202020202020202020202020202020202020202020202020202020202020202\").toString(\"hex\")).then(result => {\n    var v = result['v'] - 27;\n    v = v.toString(16);\n    if (v.length < 2) {\n      v = \"0\" + v;\n    }\n    console.log(\"Signature 0x\" + result['r'] + result['s'] + v);\n    })\n     */\n    Eth.prototype.signEIP712HashedMessage = function (path, domainSeparatorHex, hashStructMessageHex) {\n        var domainSeparator = hexBuffer(domainSeparatorHex);\n        var hashStruct = hexBuffer(hashStructMessageHex);\n        var paths = splitPath(path);\n        var buffer = Buffer.alloc(1 + paths.length * 4 + 32 + 32, 0);\n        var offset = 0;\n        buffer[0] = paths.length;\n        paths.forEach(function (element, index) {\n            buffer.writeUInt32BE(element, 1 + 4 * index);\n        });\n        offset = 1 + 4 * paths.length;\n        domainSeparator.copy(buffer, offset);\n        offset += 32;\n        hashStruct.copy(buffer, offset);\n        return this.transport\n            .send(0xe0, 0x0c, 0x00, 0x00, buffer)\n            .then(function (response) {\n            var v = response[0];\n            var r = response.slice(1, 1 + 32).toString(\"hex\");\n            var s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n            return {\n                v: v,\n                r: r,\n                s: s\n            };\n        });\n    };\n    /**\n     * get Stark public key for a given BIP 32 path.\n     * @param path a path in BIP 32 format\n     * @option boolDisplay optionally enable or not the display\n     * @return the Stark public key\n     */\n    Eth.prototype.starkGetPublicKey = function (path, boolDisplay) {\n        var paths = splitPath(path);\n        var buffer = Buffer.alloc(1 + paths.length * 4);\n        buffer[0] = paths.length;\n        paths.forEach(function (element, index) {\n            buffer.writeUInt32BE(element, 1 + 4 * index);\n        });\n        return this.transport\n            .send(0xf0, 0x02, boolDisplay ? 0x01 : 0x00, 0x00, buffer)\n            .then(function (response) {\n            return response.slice(0, response.length - 2);\n        });\n    };\n    /**\n     * sign a Stark order\n     * @param path a path in BIP 32 format\n     * @option sourceTokenAddress contract address of the source token (not present for ETH)\n     * @param sourceQuantization quantization used for the source token\n     * @option destinationTokenAddress contract address of the destination token (not present for ETH)\n     * @param destinationQuantization quantization used for the destination token\n     * @param sourceVault ID of the source vault\n     * @param destinationVault ID of the destination vault\n     * @param amountSell amount to sell\n     * @param amountBuy amount to buy\n     * @param nonce transaction nonce\n     * @param timestamp transaction validity timestamp\n     * @return the signature\n     */\n    Eth.prototype.starkSignOrder = function (path, sourceTokenAddress, sourceQuantization, destinationTokenAddress, destinationQuantization, sourceVault, destinationVault, amountSell, amountBuy, nonce, timestamp) {\n        var sourceTokenAddressHex = maybeHexBuffer(sourceTokenAddress);\n        var destinationTokenAddressHex = maybeHexBuffer(destinationTokenAddress);\n        var paths = splitPath(path);\n        var buffer = Buffer.alloc(1 + paths.length * 4 + 20 + 32 + 20 + 32 + 4 + 4 + 8 + 8 + 4 + 4, 0);\n        var offset = 0;\n        buffer[0] = paths.length;\n        paths.forEach(function (element, index) {\n            buffer.writeUInt32BE(element, 1 + 4 * index);\n        });\n        offset = 1 + 4 * paths.length;\n        if (sourceTokenAddressHex) {\n            sourceTokenAddressHex.copy(buffer, offset);\n        }\n        offset += 20;\n        Buffer.from(sourceQuantization.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, offset);\n        offset += 32;\n        if (destinationTokenAddressHex) {\n            destinationTokenAddressHex.copy(buffer, offset);\n        }\n        offset += 20;\n        Buffer.from(destinationQuantization.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, offset);\n        offset += 32;\n        buffer.writeUInt32BE(sourceVault, offset);\n        offset += 4;\n        buffer.writeUInt32BE(destinationVault, offset);\n        offset += 4;\n        Buffer.from(amountSell.toString(16).padStart(16, \"0\"), \"hex\").copy(buffer, offset);\n        offset += 8;\n        Buffer.from(amountBuy.toString(16).padStart(16, \"0\"), \"hex\").copy(buffer, offset);\n        offset += 8;\n        buffer.writeUInt32BE(nonce, offset);\n        offset += 4;\n        buffer.writeUInt32BE(timestamp, offset);\n        return this.transport\n            .send(0xf0, 0x04, 0x01, 0x00, buffer)\n            .then(function (response) {\n            var r = response.slice(1, 1 + 32).toString(\"hex\");\n            var s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n            return {\n                r: r,\n                s: s\n            };\n        });\n    };\n    /**\n     * sign a Stark order using the Starkex V2 protocol\n     * @param path a path in BIP 32 format\n     * @option sourceTokenAddress contract address of the source token (not present for ETH)\n     * @param sourceQuantizationType quantization type used for the source token\n     * @option sourceQuantization quantization used for the source token (not present for erc 721 or mintable erc 721)\n     * @option sourceMintableBlobOrTokenId mintable blob (mintable erc 20 / mintable erc 721) or token id (erc 721) associated to the source token\n     * @option destinationTokenAddress contract address of the destination token (not present for ETH)\n     * @param destinationQuantizationType quantization type used for the destination token\n     * @option destinationQuantization quantization used for the destination token (not present for erc 721 or mintable erc 721)\n     * @option destinationMintableBlobOrTokenId mintable blob (mintable erc 20 / mintable erc 721) or token id (erc 721) associated to the destination token\n     * @param sourceVault ID of the source vault\n     * @param destinationVault ID of the destination vault\n     * @param amountSell amount to sell\n     * @param amountBuy amount to buy\n     * @param nonce transaction nonce\n     * @param timestamp transaction validity timestamp\n     * @return the signature\n     */\n    Eth.prototype.starkSignOrder_v2 = function (path, sourceTokenAddress, sourceQuantizationType, sourceQuantization, sourceMintableBlobOrTokenId, destinationTokenAddress, destinationQuantizationType, destinationQuantization, destinationMintableBlobOrTokenId, sourceVault, destinationVault, amountSell, amountBuy, nonce, timestamp) {\n        var sourceTokenAddressHex = maybeHexBuffer(sourceTokenAddress);\n        var destinationTokenAddressHex = maybeHexBuffer(destinationTokenAddress);\n        if (!(sourceQuantizationType in starkQuantizationTypeMap)) {\n            throw new Error(\"eth.starkSignOrderv2 invalid source quantization type=\" +\n                sourceQuantizationType);\n        }\n        if (!(destinationQuantizationType in starkQuantizationTypeMap)) {\n            throw new Error(\"eth.starkSignOrderv2 invalid destination quantization type=\" +\n                destinationQuantizationType);\n        }\n        var paths = splitPath(path);\n        var buffer = Buffer.alloc(1 +\n            paths.length * 4 +\n            1 +\n            20 +\n            32 +\n            32 +\n            1 +\n            20 +\n            32 +\n            32 +\n            4 +\n            4 +\n            8 +\n            8 +\n            4 +\n            4, 0);\n        var offset = 0;\n        buffer[0] = paths.length;\n        paths.forEach(function (element, index) {\n            buffer.writeUInt32BE(element, 1 + 4 * index);\n        });\n        offset = 1 + 4 * paths.length;\n        buffer[offset] = starkQuantizationTypeMap[sourceQuantizationType];\n        offset++;\n        if (sourceTokenAddressHex) {\n            sourceTokenAddressHex.copy(buffer, offset);\n        }\n        offset += 20;\n        if (sourceQuantization) {\n            Buffer.from(sourceQuantization.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, offset);\n        }\n        offset += 32;\n        if (sourceMintableBlobOrTokenId) {\n            Buffer.from(sourceMintableBlobOrTokenId.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, offset);\n        }\n        offset += 32;\n        buffer[offset] = starkQuantizationTypeMap[destinationQuantizationType];\n        offset++;\n        if (destinationTokenAddressHex) {\n            destinationTokenAddressHex.copy(buffer, offset);\n        }\n        offset += 20;\n        if (destinationQuantization) {\n            Buffer.from(destinationQuantization.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, offset);\n        }\n        offset += 32;\n        if (destinationMintableBlobOrTokenId) {\n            Buffer.from(destinationMintableBlobOrTokenId.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, offset);\n        }\n        offset += 32;\n        buffer.writeUInt32BE(sourceVault, offset);\n        offset += 4;\n        buffer.writeUInt32BE(destinationVault, offset);\n        offset += 4;\n        Buffer.from(amountSell.toString(16).padStart(16, \"0\"), \"hex\").copy(buffer, offset);\n        offset += 8;\n        Buffer.from(amountBuy.toString(16).padStart(16, \"0\"), \"hex\").copy(buffer, offset);\n        offset += 8;\n        buffer.writeUInt32BE(nonce, offset);\n        offset += 4;\n        buffer.writeUInt32BE(timestamp, offset);\n        return this.transport\n            .send(0xf0, 0x04, 0x03, 0x00, buffer)\n            .then(function (response) {\n            var r = response.slice(1, 1 + 32).toString(\"hex\");\n            var s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n            return {\n                r: r,\n                s: s\n            };\n        });\n    };\n    /**\n     * sign a Stark transfer\n     * @param path a path in BIP 32 format\n     * @option transferTokenAddress contract address of the token to be transferred (not present for ETH)\n     * @param transferQuantization quantization used for the token to be transferred\n     * @param targetPublicKey target Stark public key\n     * @param sourceVault ID of the source vault\n     * @param destinationVault ID of the destination vault\n     * @param amountTransfer amount to transfer\n     * @param nonce transaction nonce\n     * @param timestamp transaction validity timestamp\n     * @return the signature\n     */\n    Eth.prototype.starkSignTransfer = function (path, transferTokenAddress, transferQuantization, targetPublicKey, sourceVault, destinationVault, amountTransfer, nonce, timestamp) {\n        var transferTokenAddressHex = maybeHexBuffer(transferTokenAddress);\n        var targetPublicKeyHex = hexBuffer(targetPublicKey);\n        var paths = splitPath(path);\n        var buffer = Buffer.alloc(1 + paths.length * 4 + 20 + 32 + 32 + 4 + 4 + 8 + 4 + 4, 0);\n        var offset = 0;\n        buffer[0] = paths.length;\n        paths.forEach(function (element, index) {\n            buffer.writeUInt32BE(element, 1 + 4 * index);\n        });\n        offset = 1 + 4 * paths.length;\n        if (transferTokenAddressHex) {\n            transferTokenAddressHex.copy(buffer, offset);\n        }\n        offset += 20;\n        Buffer.from(transferQuantization.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, offset);\n        offset += 32;\n        targetPublicKeyHex.copy(buffer, offset);\n        offset += 32;\n        buffer.writeUInt32BE(sourceVault, offset);\n        offset += 4;\n        buffer.writeUInt32BE(destinationVault, offset);\n        offset += 4;\n        Buffer.from(amountTransfer.toString(16).padStart(16, \"0\"), \"hex\").copy(buffer, offset);\n        offset += 8;\n        buffer.writeUInt32BE(nonce, offset);\n        offset += 4;\n        buffer.writeUInt32BE(timestamp, offset);\n        return this.transport\n            .send(0xf0, 0x04, 0x02, 0x00, buffer)\n            .then(function (response) {\n            var r = response.slice(1, 1 + 32).toString(\"hex\");\n            var s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n            return {\n                r: r,\n                s: s\n            };\n        });\n    };\n    /**\n     * sign a Stark transfer or conditional transfer using the Starkex V2 protocol\n     * @param path a path in BIP 32 format\n     * @option transferTokenAddress contract address of the token to be transferred (not present for ETH)\n     * @param transferQuantizationType quantization type used for the token to be transferred\n     * @option transferQuantization quantization used for the token to be transferred (not present for erc 721 or mintable erc 721)\n     * @option transferMintableBlobOrTokenId mintable blob (mintable erc 20 / mintable erc 721) or token id (erc 721) associated to the token to be transferred\n     * @param targetPublicKey target Stark public key\n     * @param sourceVault ID of the source vault\n     * @param destinationVault ID of the destination vault\n     * @param amountTransfer amount to transfer\n     * @param nonce transaction nonce\n     * @param timestamp transaction validity timestamp\n     * @option conditionalTransferAddress onchain address of the condition for a conditional transfer\n     * @option conditionalTransferFact fact associated to the condition for a conditional transfer\n     * @return the signature\n     */\n    Eth.prototype.starkSignTransfer_v2 = function (path, transferTokenAddress, transferQuantizationType, transferQuantization, transferMintableBlobOrTokenId, targetPublicKey, sourceVault, destinationVault, amountTransfer, nonce, timestamp, conditionalTransferAddress, conditionalTransferFact) {\n        var transferTokenAddressHex = maybeHexBuffer(transferTokenAddress);\n        var targetPublicKeyHex = hexBuffer(targetPublicKey);\n        var conditionalTransferAddressHex = maybeHexBuffer(conditionalTransferAddress);\n        if (!(transferQuantizationType in starkQuantizationTypeMap)) {\n            throw new Error(\"eth.starkSignTransferv2 invalid quantization type=\" +\n                transferQuantizationType);\n        }\n        var paths = splitPath(path);\n        var buffer = Buffer.alloc(1 +\n            paths.length * 4 +\n            1 +\n            20 +\n            32 +\n            32 +\n            32 +\n            4 +\n            4 +\n            8 +\n            4 +\n            4 +\n            (conditionalTransferAddressHex ? 32 + 20 : 0), 0);\n        var offset = 0;\n        buffer[0] = paths.length;\n        paths.forEach(function (element, index) {\n            buffer.writeUInt32BE(element, 1 + 4 * index);\n        });\n        offset = 1 + 4 * paths.length;\n        buffer[offset] = starkQuantizationTypeMap[transferQuantizationType];\n        offset++;\n        if (transferTokenAddressHex) {\n            transferTokenAddressHex.copy(buffer, offset);\n        }\n        offset += 20;\n        if (transferQuantization) {\n            Buffer.from(transferQuantization.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, offset);\n        }\n        offset += 32;\n        if (transferMintableBlobOrTokenId) {\n            Buffer.from(transferMintableBlobOrTokenId.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, offset);\n        }\n        offset += 32;\n        targetPublicKeyHex.copy(buffer, offset);\n        offset += 32;\n        buffer.writeUInt32BE(sourceVault, offset);\n        offset += 4;\n        buffer.writeUInt32BE(destinationVault, offset);\n        offset += 4;\n        Buffer.from(amountTransfer.toString(16).padStart(16, \"0\"), \"hex\").copy(buffer, offset);\n        offset += 8;\n        buffer.writeUInt32BE(nonce, offset);\n        offset += 4;\n        buffer.writeUInt32BE(timestamp, offset);\n        if (conditionalTransferAddressHex && conditionalTransferFact) {\n            offset += 4;\n            Buffer.from(conditionalTransferFact.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, offset);\n            offset += 32;\n            conditionalTransferAddressHex.copy(buffer, offset);\n        }\n        return this.transport\n            .send(0xf0, 0x04, conditionalTransferAddressHex ? 0x05 : 0x04, 0x00, buffer)\n            .then(function (response) {\n            var r = response.slice(1, 1 + 32).toString(\"hex\");\n            var s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n            return {\n                r: r,\n                s: s\n            };\n        });\n    };\n    /**\n     * provide quantization information before singing a deposit or withdrawal Stark powered contract call\n     *\n     * It shall be run following a provideERC20TokenInformation call for the given contract\n     *\n     * @param operationContract contract address of the token to be transferred (not present for ETH)\n     * @param operationQuantization quantization used for the token to be transferred\n     */\n    Eth.prototype.starkProvideQuantum = function (operationContract, operationQuantization) {\n        var operationContractHex = maybeHexBuffer(operationContract);\n        var buffer = Buffer.alloc(20 + 32, 0);\n        if (operationContractHex) {\n            operationContractHex.copy(buffer, 0);\n        }\n        Buffer.from(operationQuantization.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, 20);\n        return this.transport.send(0xf0, 0x08, 0x00, 0x00, buffer).then(function () { return true; }, function (e) {\n            if (e && e.statusCode === 0x6d00) {\n                // this case happen for ETH application versions not supporting Stark extensions\n                return false;\n            }\n            throw e;\n        });\n    };\n    /**\n     * provide quantization information before singing a deposit or withdrawal Stark powered contract call using the Starkex V2 protocol\n     *\n     * It shall be run following a provideERC20TokenInformation call for the given contract\n     *\n     * @param operationContract contract address of the token to be transferred (not present for ETH)\n     * @param operationQuantizationType quantization type of the token to be transferred\n     * @option operationQuantization quantization used for the token to be transferred (not present for erc 721 or mintable erc 721)\n     * @option operationMintableBlobOrTokenId mintable blob (mintable erc 20 / mintable erc 721) or token id (erc 721) of the token to be transferred\n     */\n    Eth.prototype.starkProvideQuantum_v2 = function (operationContract, operationQuantizationType, operationQuantization, operationMintableBlobOrTokenId) {\n        var operationContractHex = maybeHexBuffer(operationContract);\n        if (!(operationQuantizationType in starkQuantizationTypeMap)) {\n            throw new Error(\"eth.starkProvideQuantumV2 invalid quantization type=\" +\n                operationQuantizationType);\n        }\n        var buffer = Buffer.alloc(20 + 32 + 32, 0);\n        var offset = 0;\n        if (operationContractHex) {\n            operationContractHex.copy(buffer, offset);\n        }\n        offset += 20;\n        if (operationQuantization) {\n            Buffer.from(operationQuantization.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, offset);\n        }\n        offset += 32;\n        if (operationMintableBlobOrTokenId) {\n            Buffer.from(operationMintableBlobOrTokenId.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, offset);\n        }\n        return this.transport\n            .send(0xf0, 0x08, starkQuantizationTypeMap[operationQuantizationType], 0x00, buffer)\n            .then(function () { return true; }, function (e) {\n            if (e && e.statusCode === 0x6d00) {\n                // this case happen for ETH application versions not supporting Stark extensions\n                return false;\n            }\n            throw e;\n        });\n    };\n    /**\n     * sign the given hash over the Stark curve\n     * It is intended for speed of execution in case an unknown Stark model is pushed and should be avoided as much as possible.\n     * @param path a path in BIP 32 format\n     * @param hash hexadecimal hash to sign\n     * @return the signature\n     */\n    Eth.prototype.starkUnsafeSign = function (path, hash) {\n        var hashHex = hexBuffer(hash);\n        var paths = splitPath(path);\n        var buffer = Buffer.alloc(1 + paths.length * 4 + 32);\n        var offset = 0;\n        buffer[0] = paths.length;\n        paths.forEach(function (element, index) {\n            buffer.writeUInt32BE(element, 1 + 4 * index);\n        });\n        offset = 1 + 4 * paths.length;\n        hashHex.copy(buffer, offset);\n        return this.transport\n            .send(0xf0, 0x0a, 0x00, 0x00, buffer)\n            .then(function (response) {\n            var r = response.slice(1, 1 + 32).toString(\"hex\");\n            var s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n            return {\n                r: r,\n                s: s\n            };\n        });\n    };\n    /**\n     * get an Ethereum 2 BLS-12 381 public key for a given BIP 32 path.\n     * @param path a path in BIP 32 format\n     * @option boolDisplay optionally enable or not the display\n     * @return an object with a publicKey\n     * @example\n     * eth.eth2GetPublicKey(\"12381/3600/0/0\").then(o => o.publicKey)\n     */\n    Eth.prototype.eth2GetPublicKey = function (path, boolDisplay) {\n        var paths = splitPath(path);\n        var buffer = Buffer.alloc(1 + paths.length * 4);\n        buffer[0] = paths.length;\n        paths.forEach(function (element, index) {\n            buffer.writeUInt32BE(element, 1 + 4 * index);\n        });\n        return this.transport\n            .send(0xe0, 0x0e, boolDisplay ? 0x01 : 0x00, 0x00, buffer)\n            .then(function (response) {\n            return {\n                publicKey: response.slice(0, -2).toString(\"hex\")\n            };\n        });\n    };\n    /**\n     * Set the index of a Withdrawal key used as withdrawal credentials in an ETH 2 deposit contract call signature\n     *\n     * It shall be run before the ETH 2 deposit transaction is signed. If not called, the index is set to 0\n     *\n     * @param withdrawalIndex index path in the EIP 2334 path m/12381/3600/withdrawalIndex/0\n     * @return True if the method was executed successfully\n     */\n    Eth.prototype.eth2SetWithdrawalIndex = function (withdrawalIndex) {\n        var buffer = Buffer.alloc(4, 0);\n        buffer.writeUInt32BE(withdrawalIndex, 0);\n        return this.transport.send(0xe0, 0x10, 0x00, 0x00, buffer).then(function () { return true; }, function (e) {\n            if (e && e.statusCode === 0x6d00) {\n                // this case happen for ETH application versions not supporting ETH 2\n                return false;\n            }\n            throw e;\n        });\n    };\n    /**\n     * Set the name of the external plugin that should be used to parse the next transaction\n     *\n     * @param pluginName string containing the name of the plugin, must have length between 1 and 30 bytes\n     * @return True if the method was executed successfully\n     */\n    Eth.prototype.setExternalPlugin = function (pluginName, contractAddress, selector) {\n        return setExternalPlugin(this.transport, pluginName, selector);\n    };\n    /**\n     * Set the plugin (internal or external) that should be used to parse the next transaction\n     *\n     * @param data string containing the payload and signature that will be parsed and verified by the device.\n     * @return True if the method was executed successfully\n     */\n    Eth.prototype.setPlugin = function (data) {\n        return setPlugin(this.transport, data);\n    };\n    return Eth;\n}());\nexport default Eth;\n// internal helpers\nfunction provideERC20TokenInformation(transport, data) {\n    return transport.send(0xe0, 0x0a, 0x00, 0x00, data).then(function () { return true; }, function (e) {\n        if (e && e.statusCode === 0x6d00) {\n            // this case happen for older version of ETH app, since older app version had the ERC20 data hardcoded, it's fine to assume it worked.\n            // we return a flag to know if the call was effective or not\n            return false;\n        }\n        throw e;\n    });\n}\nfunction provideNFTInformation(transport, data) {\n    return transport.send(0xe0, 0x14, 0x00, 0x00, data).then(function () { return true; }, function (e) {\n        if (e && e.statusCode === 0x6a80) {\n            // some issue with providing the data\n            return false;\n        }\n        if (e && e.statusCode === 0x6d00) {\n            // ignore older version of ETH app\n            return false;\n        }\n        throw e;\n    });\n}\nfunction setExternalPlugin(transport, payload, signature) {\n    var payloadBuffer = Buffer.from(payload, \"hex\");\n    var signatureBuffer = Buffer.from(signature, \"hex\");\n    var buffer = Buffer.concat([payloadBuffer, signatureBuffer]);\n    return transport.send(0xe0, 0x12, 0x00, 0x00, buffer).then(function () { return true; }, function (e) {\n        if (e && e.statusCode === 0x6a80) {\n            // this case happen when the plugin name is too short or too long\n            return false;\n        }\n        else if (e && e.statusCode === 0x6984) {\n            // this case happen when the plugin requested is not installed on the device\n            return false;\n        }\n        else if (e && e.statusCode === 0x6d00) {\n            // this case happen for older version of ETH app\n            return false;\n        }\n        throw e;\n    });\n}\nfunction setPlugin(transport, data) {\n    var buffer = Buffer.from(data, \"hex\");\n    return transport.send(0xe0, 0x16, 0x00, 0x00, buffer).then(function () { return true; }, function (e) {\n        if (e && e.statusCode === 0x6a80) {\n            // this case happen when the plugin name is too short or too long\n            return false;\n        }\n        else if (e && e.statusCode === 0x6984) {\n            // this case happen when the plugin requested is not installed on the device\n            return false;\n        }\n        else if (e && e.statusCode === 0x6d00) {\n            // this case happen for older version of ETH app\n            return false;\n        }\n        throw e;\n    });\n}\n//# sourceMappingURL=Eth.js.map"]},"metadata":{},"sourceType":"module"}