{"ast":null,"code":"import { ethTokenAddress } from 'constants/ethContractAddresses';\nimport { POLYGON_CHAIN_DATA } from './connectors';\nconst baseURL = 'https://api.coingecko.com/api/v3';\nexport const fetchHistoricalTokenMarketData = (id, baseCurrency = 'usd') => {\n  const coingeckoMaxTokenDataUrl = baseURL + `/coins/${id}/market_chart?vs_currency=${baseCurrency}&days=max&interval=daily`;\n  const coingeckoHourlyTokenDataUrl = baseURL + `/coins/${id}/market_chart?vs_currency=${baseCurrency}&days=90`;\n  return Promise.all([fetch(coingeckoMaxTokenDataUrl), fetch(coingeckoHourlyTokenDataUrl)]).then(responses => Promise.all(responses.map(response => response.json()))).then(data => {\n    const prices = data[0].prices,\n          hourlyPrices = data[1].prices,\n          marketcaps = data[0].market_caps,\n          volumes = data[0].total_volumes;\n    return {\n      prices,\n      hourlyPrices,\n      marketcaps,\n      volumes\n    };\n  }).catch(error => console.log(error));\n};\nexport const fetchHistoricalTokenMarketDataOnPolygon = polygonTokenAddress => {\n  const coingeckoTokenIdentifier = `${POLYGON_CHAIN_DATA.coingeckoId}/contract/${polygonTokenAddress}`;\n  return fetchHistoricalTokenMarketData(coingeckoTokenIdentifier);\n};\n\nconst getAssetPlatform = chainId => {\n  if (chainId === POLYGON_CHAIN_DATA.chainId) return 'polygon-pos';\n  return 'ethereum';\n};\n\nexport const fetchCoingeckoTokenPrice = async (address, chainId, baseCurrency = 'usd') => {\n  if (address === ethTokenAddress) {\n    const getPriceUrl = baseURL + `/simple/price/?ids=ethereum&vs_currencies=${baseCurrency}`;\n    const resp = await fetch(getPriceUrl);\n    const data = await resp.json().catch(err => {\n      return 0;\n    });\n    if (data === 0 || !data['ethereum']) return 0;\n    return data['ethereum'][baseCurrency];\n  }\n\n  const getPriceUrl = baseURL + `/simple/token_price/${getAssetPlatform(chainId)}/?contract_addresses=${address}&vs_currencies=${baseCurrency}`;\n  const resp = await fetch(getPriceUrl);\n  const data = await resp.json().catch(err => {\n    return 0;\n  });\n  if (data === 0 || !data[address.toLowerCase()]) return 0;\n  return data[address.toLowerCase()][baseCurrency];\n};","map":{"version":3,"sources":["/Users/safahi/Documents/GitHub/appwebsite/src/utils/coingeckoApi.ts"],"names":["ethTokenAddress","POLYGON_CHAIN_DATA","baseURL","fetchHistoricalTokenMarketData","id","baseCurrency","coingeckoMaxTokenDataUrl","coingeckoHourlyTokenDataUrl","Promise","all","fetch","then","responses","map","response","json","data","prices","hourlyPrices","marketcaps","market_caps","volumes","total_volumes","catch","error","console","log","fetchHistoricalTokenMarketDataOnPolygon","polygonTokenAddress","coingeckoTokenIdentifier","coingeckoId","getAssetPlatform","chainId","fetchCoingeckoTokenPrice","address","getPriceUrl","resp","err","toLowerCase"],"mappings":"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","sourcesContent":["import { ethTokenAddress } from 'constants/ethContractAddresses'\n\nimport { POLYGON_CHAIN_DATA } from './connectors'\n\nconst baseURL = 'https://api.coingecko.com/api/v3'\n\nexport const fetchHistoricalTokenMarketData = (\n  id: string,\n  baseCurrency = 'usd'\n) => {\n  const coingeckoMaxTokenDataUrl =\n    baseURL +\n    `/coins/${id}/market_chart?vs_currency=${baseCurrency}&days=max&interval=daily`\n  const coingeckoHourlyTokenDataUrl =\n    baseURL + `/coins/${id}/market_chart?vs_currency=${baseCurrency}&days=90`\n\n  return Promise.all([\n    fetch(coingeckoMaxTokenDataUrl),\n    fetch(coingeckoHourlyTokenDataUrl),\n  ])\n    .then((responses) =>\n      Promise.all(responses.map((response) => response.json()))\n    )\n    .then((data) => {\n      const prices = data[0].prices,\n        hourlyPrices = data[1].prices,\n        marketcaps = data[0].market_caps,\n        volumes = data[0].total_volumes\n\n      return { prices, hourlyPrices, marketcaps, volumes }\n    })\n    .catch((error) => console.log(error))\n}\n\nexport const fetchHistoricalTokenMarketDataOnPolygon = (\n  polygonTokenAddress?: string\n) => {\n  const coingeckoTokenIdentifier = `${POLYGON_CHAIN_DATA.coingeckoId}/contract/${polygonTokenAddress}`\n\n  return fetchHistoricalTokenMarketData(coingeckoTokenIdentifier)\n}\n\nconst getAssetPlatform = (chainId: number) => {\n  if (chainId === POLYGON_CHAIN_DATA.chainId) return 'polygon-pos'\n  return 'ethereum'\n}\n\nexport const fetchCoingeckoTokenPrice = async (\n  address: string,\n  chainId: number,\n  baseCurrency = 'usd'\n): Promise<number> => {\n  if (address === ethTokenAddress) {\n    const getPriceUrl =\n      baseURL + `/simple/price/?ids=ethereum&vs_currencies=${baseCurrency}`\n\n    const resp = await fetch(getPriceUrl)\n\n    const data = await resp.json().catch((err) => {\n      return 0\n    })\n\n    if (data === 0 || !data['ethereum']) return 0\n\n    return data['ethereum'][baseCurrency]\n  }\n\n  const getPriceUrl =\n    baseURL +\n    `/simple/token_price/${getAssetPlatform(\n      chainId\n    )}/?contract_addresses=${address}&vs_currencies=${baseCurrency}`\n\n  const resp = await fetch(getPriceUrl)\n\n  const data = await resp.json().catch((err) => {\n    return 0\n  })\n\n  if (data === 0 || !data[address.toLowerCase()]) return 0\n\n  return data[address.toLowerCase()][baseCurrency]\n}\n"]},"metadata":{},"sourceType":"module"}