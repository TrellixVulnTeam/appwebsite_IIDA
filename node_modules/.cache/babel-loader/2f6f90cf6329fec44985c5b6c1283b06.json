{"ast":null,"code":"import axios from 'axios';\nimport querystring from 'querystring';\nimport { polygonTokenInfo, tokenInfo } from 'constants/tokenInfo';\nimport BigNumber from 'utils/bignumber';\nimport { fetchCoingeckoTokenPrice } from './coingeckoApi';\nimport { MAINNET_CHAIN_DATA, POLYGON_CHAIN_DATA } from './connectors';\nexport const getZeroExTradeData = async (isExactInput, isUserBuying, currencyToken, buySellToken, buySellAmount, chainId) => {\n  let sellToken;\n  let buyToken;\n\n  if (isUserBuying) {\n    buyToken = buySellToken;\n    sellToken = currencyToken;\n  } else {\n    buyToken = currencyToken;\n    sellToken = buySellToken;\n  }\n\n  const params = getApiParams(isExactInput, sellToken, buyToken, buySellAmount, chainId);\n  let resp;\n  if (chainId === MAINNET_CHAIN_DATA.chainId) resp = await axios.get(`https://api.0x.org/swap/v1/quote?${querystring.stringify(params)}`);else resp = await axios.get(`https://polygon.api.0x.org/swap/v1/quote?${querystring.stringify(params)}`);\n  const zeroExData = resp.data;\n  return await processApiResult(zeroExData, isExactInput, sellToken, buyToken, buySellAmount, chainId);\n};\n\nconst getApiParams = (isExactInput, sellToken, buyToken, buySellAmount, chainId) => {\n  let params;\n\n  if (chainId === MAINNET_CHAIN_DATA.chainId) {\n    params = {\n      sellToken: tokenInfo[sellToken].address,\n      buyToken: tokenInfo[buyToken].address\n    };\n\n    if (isExactInput) {\n      params.sellAmount = getDecimalAdjustedAmount(buySellAmount, tokenInfo[sellToken].decimals);\n    } else {\n      params.buyAmount = getDecimalAdjustedAmount(buySellAmount, tokenInfo[buyToken].decimals);\n    }\n  } else {\n    params = {\n      sellToken: polygonTokenInfo[sellToken].address,\n      buyToken: polygonTokenInfo[buyToken].address\n    };\n\n    if (isExactInput) {\n      params.sellAmount = getDecimalAdjustedAmount(buySellAmount, polygonTokenInfo[sellToken].decimals);\n    } else {\n      params.buyAmount = getDecimalAdjustedAmount(buySellAmount, polygonTokenInfo[buyToken].decimals);\n    }\n  }\n\n  return params;\n}; // Adds some additional information to the ZeroExData return object. This extra information is only used for display purposes, and\n// will have no effect on the outcome of the transaction\n\n\nconst processApiResult = async (zeroExData, isExactInput, sellToken, buyToken, buySellAmount, chainId) => {\n  const tokenInfoByChain = chainId === POLYGON_CHAIN_DATA.chainId ? polygonTokenInfo : tokenInfo;\n  zeroExData.displaySellAmount = getDisplayAdjustedAmount(zeroExData.sellAmount, tokenInfoByChain[sellToken].decimals);\n  zeroExData.displayBuyAmount = getDisplayAdjustedAmount(zeroExData.buyAmount, tokenInfoByChain[buyToken].decimals);\n  const guaranteedPrice = new BigNumber(zeroExData.guaranteedPrice);\n  zeroExData.minOutput = isExactInput ? guaranteedPrice.multipliedBy(new BigNumber(zeroExData.sellAmount)).dividedBy(new BigNumber('1e' + tokenInfoByChain[sellToken].decimals)) : new BigNumber(buySellAmount);\n  zeroExData.maxInput = isExactInput ? new BigNumber(buySellAmount) : guaranteedPrice.multipliedBy(new BigNumber(zeroExData.buyAmount)).dividedBy(new BigNumber('1e' + tokenInfoByChain[buyToken].decimals));\n  zeroExData.formattedSources = formatSources(zeroExData.sources);\n  const buyTokenPrice = await fetchCoingeckoTokenPrice(zeroExData.buyTokenAddress, chainId);\n  zeroExData.buyTokenCost = (buyTokenPrice * zeroExData.displayBuyAmount).toFixed(2);\n  const sellTokenPrice = await fetchCoingeckoTokenPrice(zeroExData.sellTokenAddress, chainId);\n  zeroExData.sellTokenCost = (sellTokenPrice * zeroExData.displaySellAmount).toFixed(2);\n  return zeroExData;\n};\n\nexport const getDisplayAdjustedAmount = (amount, decimals) => {\n  return new BigNumber(amount).dividedBy(new BigNumber('1e' + decimals)).toNumber();\n};\n\nconst formatSources = sources => {\n  const activeSources = [];\n  sources.forEach(source => {\n    if (source.proportion !== '0') activeSources.push(source);\n  });\n  const sourceNames = activeSources.map(source => source.name.replaceAll('_', ' '));\n  return sourceNames.length === 1 ? sourceNames[0] : sourceNames.slice(0, -1).join(', ') + ' and ' + sourceNames.slice(-1);\n};\n\nconst getDecimalAdjustedAmount = (amount, decimals) => {\n  return new BigNumber(amount).multipliedBy(new BigNumber('1e' + decimals)).toString();\n};","map":{"version":3,"sources":["/Users/safahi/Documents/GitHub/appwebsite/src/utils/zeroExUtils.ts"],"names":["axios","querystring","polygonTokenInfo","tokenInfo","BigNumber","fetchCoingeckoTokenPrice","MAINNET_CHAIN_DATA","POLYGON_CHAIN_DATA","getZeroExTradeData","isExactInput","isUserBuying","currencyToken","buySellToken","buySellAmount","chainId","sellToken","buyToken","params","getApiParams","resp","get","stringify","zeroExData","data","processApiResult","address","sellAmount","getDecimalAdjustedAmount","decimals","buyAmount","tokenInfoByChain","displaySellAmount","getDisplayAdjustedAmount","displayBuyAmount","guaranteedPrice","minOutput","multipliedBy","dividedBy","maxInput","formattedSources","formatSources","sources","buyTokenPrice","buyTokenAddress","buyTokenCost","toFixed","sellTokenPrice","sellTokenAddress","sellTokenCost","amount","toNumber","activeSources","forEach","source","proportion","push","sourceNames","map","name","replaceAll","length","slice","join","toString"],"mappings":"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","sourcesContent":["import axios from 'axios'\nimport querystring from 'querystring'\n\nimport { polygonTokenInfo, tokenInfo } from 'constants/tokenInfo'\nimport BigNumber from 'utils/bignumber'\n\nimport { ZeroExData } from '../contexts/BuySell/types'\n\nimport { fetchCoingeckoTokenPrice } from './coingeckoApi'\nimport { MAINNET_CHAIN_DATA, POLYGON_CHAIN_DATA } from './connectors'\n\nexport const getZeroExTradeData = async (\n  isExactInput: boolean,\n  isUserBuying: boolean,\n  currencyToken: string,\n  buySellToken: string,\n  buySellAmount: string,\n  chainId: number\n): Promise<ZeroExData> => {\n  let sellToken\n  let buyToken\n\n  if (isUserBuying) {\n    buyToken = buySellToken\n    sellToken = currencyToken\n  } else {\n    buyToken = currencyToken\n    sellToken = buySellToken\n  }\n\n  const params = getApiParams(\n    isExactInput,\n    sellToken,\n    buyToken,\n    buySellAmount,\n    chainId\n  )\n  let resp\n  if (chainId === MAINNET_CHAIN_DATA.chainId)\n    resp = await axios.get(\n      `https://api.0x.org/swap/v1/quote?${querystring.stringify(params)}`\n    )\n  else\n    resp = await axios.get(\n      `https://polygon.api.0x.org/swap/v1/quote?${querystring.stringify(\n        params\n      )}`\n    )\n\n  const zeroExData: ZeroExData = resp.data\n  return await processApiResult(\n    zeroExData,\n    isExactInput,\n    sellToken,\n    buyToken,\n    buySellAmount,\n    chainId\n  )\n}\n\nconst getApiParams = (\n  isExactInput: boolean,\n  sellToken: string,\n  buyToken: string,\n  buySellAmount: string,\n  chainId: number\n): any => {\n  let params: any\n  if (chainId === MAINNET_CHAIN_DATA.chainId) {\n    params = {\n      sellToken: tokenInfo[sellToken].address,\n      buyToken: tokenInfo[buyToken].address,\n    }\n    if (isExactInput) {\n      params.sellAmount = getDecimalAdjustedAmount(\n        buySellAmount,\n        tokenInfo[sellToken].decimals\n      )\n    } else {\n      params.buyAmount = getDecimalAdjustedAmount(\n        buySellAmount,\n        tokenInfo[buyToken].decimals\n      )\n    }\n  } else {\n    params = {\n      sellToken: polygonTokenInfo[sellToken].address,\n      buyToken: polygonTokenInfo[buyToken].address,\n    }\n    if (isExactInput) {\n      params.sellAmount = getDecimalAdjustedAmount(\n        buySellAmount,\n        polygonTokenInfo[sellToken].decimals\n      )\n    } else {\n      params.buyAmount = getDecimalAdjustedAmount(\n        buySellAmount,\n        polygonTokenInfo[buyToken].decimals\n      )\n    }\n  }\n\n  return params\n}\n\n// Adds some additional information to the ZeroExData return object. This extra information is only used for display purposes, and\n// will have no effect on the outcome of the transaction\nconst processApiResult = async (\n  zeroExData: ZeroExData,\n  isExactInput: boolean,\n  sellToken: string,\n  buyToken: string,\n  buySellAmount: string,\n  chainId: number\n): Promise<ZeroExData> => {\n  const tokenInfoByChain =\n    chainId === POLYGON_CHAIN_DATA.chainId ? polygonTokenInfo : tokenInfo\n\n  zeroExData.displaySellAmount = getDisplayAdjustedAmount(\n    zeroExData.sellAmount,\n    tokenInfoByChain[sellToken].decimals\n  )\n  zeroExData.displayBuyAmount = getDisplayAdjustedAmount(\n    zeroExData.buyAmount,\n    tokenInfoByChain[buyToken].decimals\n  )\n\n  const guaranteedPrice = new BigNumber(zeroExData.guaranteedPrice)\n  zeroExData.minOutput = isExactInput\n    ? guaranteedPrice\n        .multipliedBy(new BigNumber(zeroExData.sellAmount))\n        .dividedBy(new BigNumber('1e' + tokenInfoByChain[sellToken].decimals))\n    : new BigNumber(buySellAmount)\n  zeroExData.maxInput = isExactInput\n    ? new BigNumber(buySellAmount)\n    : guaranteedPrice\n        .multipliedBy(new BigNumber(zeroExData.buyAmount))\n        .dividedBy(new BigNumber('1e' + tokenInfoByChain[buyToken].decimals))\n\n  zeroExData.formattedSources = formatSources(zeroExData.sources)\n\n  const buyTokenPrice = await fetchCoingeckoTokenPrice(\n    zeroExData.buyTokenAddress,\n    chainId\n  )\n  zeroExData.buyTokenCost = (\n    buyTokenPrice * zeroExData.displayBuyAmount\n  ).toFixed(2)\n\n  const sellTokenPrice: number = await fetchCoingeckoTokenPrice(\n    zeroExData.sellTokenAddress,\n    chainId\n  )\n  zeroExData.sellTokenCost = (\n    sellTokenPrice * zeroExData.displaySellAmount\n  ).toFixed(2)\n\n  return zeroExData\n}\n\nexport const getDisplayAdjustedAmount = (\n  amount: string,\n  decimals: number\n): number => {\n  return new BigNumber(amount)\n    .dividedBy(new BigNumber('1e' + decimals))\n    .toNumber()\n}\n\nconst formatSources = (\n  sources: { name: string; proportion: string }[]\n): string => {\n  const activeSources: any[] = []\n\n  sources.forEach((source: any) => {\n    if (source.proportion !== '0') activeSources.push(source)\n  })\n  const sourceNames: string[] = activeSources.map((source) =>\n    source.name.replaceAll('_', ' ')\n  )\n\n  return sourceNames.length === 1\n    ? sourceNames[0]\n    : sourceNames.slice(0, -1).join(', ') + ' and ' + sourceNames.slice(-1)\n}\n\nconst getDecimalAdjustedAmount = (amount: string, decimals: number): string => {\n  return new BigNumber(amount)\n    .multipliedBy(new BigNumber('1e' + decimals))\n    .toString()\n}\n"]},"metadata":{},"sourceType":"module"}