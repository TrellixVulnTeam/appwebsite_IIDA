{"ast":null,"code":"import Web3 from 'web3';\nimport { nftPositionManagerAddress, uniswapV3FactoryAddress, uniswapV3StakerAddress } from 'constants/ethContractAddresses';\nimport nftPositionManagerAbi from 'index-sdk/abi/NftPositionManager.json';\nimport uniswapV3FactoryAbi from 'index-sdk/abi/uniswapV3Factory.json';\nimport uniswapV3StakerAbi from 'index-sdk/abi/uniswapV3Staker.json';\nimport BigNumber from 'utils/bignumber';\n/**\n * Returns all NFTs eligible for the target farm for the target user account.\n * These are effectively all unstaked NFT IDs.\n * @param farm - Target farm to check NFTs against\n * @param user - User's ethereum account\n * @param provider - Ethereum network provider\n * @returns - A list of NFT IDs\n */\n\nexport async function getValidIds(farm, user, provider) {\n  const nftPositionManager = getNftPositionManager(provider);\n  const factory = getFactory(provider);\n  const totalNfts = await nftPositionManager.methods.balanceOf(user).call();\n  const validIds = [];\n\n  for (let i = 0; i < totalNfts; i++) {\n    const tokenId = await nftPositionManager.methods.tokenOfOwnerByIndex(user, i).call(); // check if this NFT is an LP for a currently active farm\n\n    if (await isTokenFromValidPool(tokenId, farm, nftPositionManager, factory)) {\n      validIds.push(tokenId);\n    }\n  }\n\n  return validIds;\n}\nexport async function depositAndStake(nftId, farm, user, provider) {\n  const nftPositionManager = getNftPositionManager(provider);\n  const stakeTokenType = {\n    IncentiveKey: {\n      rewardToken: 'address',\n      pool: 'address',\n      startTime: 'uint256',\n      endTime: 'uint256',\n      refundee: 'address'\n    }\n  };\n  const currentFarmNumber = getMostRecentFarmNumber(farm);\n  const data = new Web3(provider).eth.abi.encodeParameters([stakeTokenType], [farm.farms[currentFarmNumber]]); // add initially staked farms in transfer data\n\n  return new Promise(resolve => {\n    nftPositionManager.methods.safeTransferFrom(user, uniswapV3StakerAddress, nftId, data).send({\n      from: user\n    }).on('transactionHash', txId => {\n      if (!txId) resolve(null);\n      resolve(txId);\n    }).on('error', error => {\n      console.log(error);\n      resolve(null);\n    });\n  });\n}\nexport async function withdraw(nftId, user, farm, provider) {\n  const stakingContract = getStakingContract(provider);\n  const stakedFarmIds = await getCurrentStakes(farm, nftId, provider);\n  const data = await Promise.all(stakedFarmIds.map(async farmId => {\n    return stakingContract.methods.unstakeToken(farm.farms[farmId], nftId).encodeABI();\n  }));\n  data.push(stakingContract.methods.withdrawToken(nftId, user, '0x').encodeABI());\n  return new Promise(resolve => {\n    stakingContract.methods.multicall(data).send({\n      from: user\n    }).on('transactionHash', txId => {\n      if (!txId) resolve(null);\n      resolve(txId);\n    }).on('error', error => {\n      console.log(error);\n      resolve(null);\n    });\n  });\n}\nexport async function getAccruedRewardsAmount(user, rewardToken, provider) {\n  const stakingContract = getStakingContract(provider);\n  return await stakingContract.methods.rewards(rewardToken, user).call();\n}\nexport async function getAllPendingRewardsAmount(user, farm, provider) {\n  const stakingContract = getStakingContract(provider);\n  const deposits = await getAllDepositedTokens(user, farm, provider);\n  const amounts = await Promise.all(deposits.map(async id => {\n    const stakes = await getCurrentStakes(farm, id, provider);\n    const amounts = await Promise.all(stakes.map(async farmNumber => {\n      const rewardInfo = await stakingContract.methods.getRewardInfo(farm.farms[farmNumber], id).call();\n      return new BigNumber(rewardInfo.reward);\n    }));\n    return amounts.reduce((a, b) => {\n      return a.plus(b);\n    }, new BigNumber(0));\n  }));\n  return amounts.reduce((a, b) => {\n    return a.plus(b);\n  }, new BigNumber(0));\n}\nexport async function getIndividualPendingRewardsAmount(user, farm, nftId, provider) {\n  const stakingContract = getStakingContract(provider);\n  const stakes = await getCurrentStakes(farm, nftId, provider);\n  const pendingRewards = await Promise.all(stakes.map(async farmNumber => {\n    const rewardInfo = await stakingContract.methods.getRewardInfo(farm.farms[farmNumber], nftId).call();\n    return new BigNumber(rewardInfo.reward);\n  }));\n  return pendingRewards.reduce((a, b) => {\n    return a.plus(b);\n  }, new BigNumber(0));\n}\nexport async function claimAccruedRewards(user, rewardToken, provider) {\n  const stakingContract = getStakingContract(provider);\n  return new Promise(resolve => {\n    stakingContract.methods.claimReward(rewardToken, user, 0).send({\n      from: user\n    }).on('transactionHash', txId => {\n      if (!txId) resolve(null);\n      resolve(txId);\n    }).on('error', error => {\n      console.log(error);\n      resolve(null);\n    });\n  });\n}\nexport async function getAllDepositedTokens(user, farm, provider) {\n  const options = {\n    fromBlock: 0,\n    toBlock: 'latest',\n    filter: {\n      from: user,\n      to: uniswapV3StakerAddress || ''\n    }\n  };\n  const nftPositionManager = getNftPositionManager(provider);\n  const stakingContract = getStakingContract(provider);\n  const factory = getFactory(provider);\n  const tokenIdsPotentialDuplicates = (await nftPositionManager.getPastEvents('Transfer', options)).map(event => event.returnValues['tokenId']);\n  const tokenIds = Array.from(new Set(tokenIdsPotentialDuplicates));\n  const currentlyDeposited = [];\n\n  for (let i = 0; i < tokenIds.length; i++) {\n    const depositInfo = await stakingContract.methods.deposits(tokenIds[i]).call();\n    const isValidPoolToken = await isTokenFromValidPool(tokenIds[i], farm, nftPositionManager, factory);\n\n    if (isValidPoolToken && (depositInfo.tickLower !== '0' || depositInfo.tickUpper !== '0')) {\n      currentlyDeposited.push(parseInt(tokenIds[i]));\n    }\n  }\n\n  return currentlyDeposited;\n} // Helper functions\n\nexport function getMostRecentFarmNumber(farm) {\n  return farm.farms.length - 1;\n}\n\nasync function getCurrentStakes(farm, nftId, provider) {\n  const stakingContract = getStakingContract(provider);\n  const currentStakes = [];\n\n  for (let i = 0; i < farm.farms.length; i++) {\n    const incentiveId = deriveIncentiveId(provider, farm.farms[i]);\n    const stakeInfo = await stakingContract.methods.stakes(nftId, incentiveId).call();\n\n    if (stakeInfo.liquidity !== '0') {\n      currentStakes.push(i);\n    }\n  }\n\n  return currentStakes;\n}\n\nfunction getNftPositionManager(provider) {\n  const web3 = new Web3(provider);\n  return new web3.eth.Contract(nftPositionManagerAbi, nftPositionManagerAddress);\n}\n\nfunction getFactory(provider) {\n  const web3 = new Web3(provider);\n  return new web3.eth.Contract(uniswapV3FactoryAbi, uniswapV3FactoryAddress);\n}\n\nfunction getStakingContract(provider) {\n  const web3 = new Web3(provider);\n  return new web3.eth.Contract(uniswapV3StakerAbi, uniswapV3StakerAddress);\n}\n\nfunction deriveIncentiveId(provider, farmPlot) {\n  const stakeTokenType = {\n    IncentiveKey: {\n      rewardToken: 'address',\n      pool: 'address',\n      startTime: 'uint256',\n      endTime: 'uint256',\n      refundee: 'address'\n    }\n  };\n  const data = new Web3(provider).eth.abi.encodeParameters([stakeTokenType], [farmPlot]);\n  return Web3.utils.keccak256(data);\n}\n\nasync function isTokenFromValidPool(tokenId, farm, nftPositionManager, factory) {\n  var _farm$pool;\n\n  const position = await nftPositionManager.methods.positions(tokenId).call();\n  const nftPoolAddress = await factory.methods.getPool(position.token0, position.token1, position.fee).call();\n  return ((_farm$pool = farm.pool) === null || _farm$pool === void 0 ? void 0 : _farm$pool.toLowerCase()) === (nftPoolAddress === null || nftPoolAddress === void 0 ? void 0 : nftPoolAddress.toLowerCase());\n}\n\nexport const getUpcomingFarms = farm => {\n  return farm.farms.filter(farm => {\n    const now = Date.now();\n    const formattedStartTime = farm.startTime * 1000;\n    return now < formattedStartTime;\n  });\n};\nexport const getActiveFarms = farm => {\n  return farm.farms.filter(farm => {\n    const now = Date.now();\n    const formattedStartTime = farm.startTime * 1000;\n    const formattedEndTime = farm.endTime * 1000;\n    return now > formattedStartTime && now < formattedEndTime;\n  });\n};\nexport const getExpiredFarms = farm => {\n  return farm.farms.filter(farm => {\n    const now = Date.now();\n    const formattedEndTime = farm.endTime * 1000;\n    return now > formattedEndTime;\n  });\n};","map":{"version":3,"sources":["/Users/safahi/Documents/GitHub/appwebsite/src/index-sdk/uniV3Farm.ts"],"names":["Web3","nftPositionManagerAddress","uniswapV3FactoryAddress","uniswapV3StakerAddress","nftPositionManagerAbi","uniswapV3FactoryAbi","uniswapV3StakerAbi","BigNumber","getValidIds","farm","user","provider","nftPositionManager","getNftPositionManager","factory","getFactory","totalNfts","methods","balanceOf","call","validIds","i","tokenId","tokenOfOwnerByIndex","isTokenFromValidPool","push","depositAndStake","nftId","stakeTokenType","IncentiveKey","rewardToken","pool","startTime","endTime","refundee","currentFarmNumber","getMostRecentFarmNumber","data","eth","abi","encodeParameters","farms","Promise","resolve","safeTransferFrom","send","from","on","txId","error","console","log","withdraw","stakingContract","getStakingContract","stakedFarmIds","getCurrentStakes","all","map","farmId","unstakeToken","encodeABI","withdrawToken","multicall","getAccruedRewardsAmount","rewards","getAllPendingRewardsAmount","deposits","getAllDepositedTokens","amounts","id","stakes","farmNumber","rewardInfo","getRewardInfo","reward","reduce","a","b","plus","getIndividualPendingRewardsAmount","pendingRewards","claimAccruedRewards","claimReward","options","fromBlock","toBlock","filter","to","tokenIdsPotentialDuplicates","getPastEvents","event","returnValues","tokenIds","Array","Set","currentlyDeposited","length","depositInfo","isValidPoolToken","tickLower","tickUpper","parseInt","currentStakes","incentiveId","deriveIncentiveId","stakeInfo","liquidity","web3","Contract","farmPlot","utils","keccak256","position","positions","nftPoolAddress","getPool","token0","token1","fee","toLowerCase","getUpcomingFarms","now","Date","formattedStartTime","getActiveFarms","formattedEndTime","getExpiredFarms"],"mappings":"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","sourcesContent":["import Web3 from 'web3'\nimport { provider } from 'web3-core'\nimport { AbiItem } from 'web3-utils'\n\nimport {\n  nftPositionManagerAddress,\n  uniswapV3FactoryAddress,\n  uniswapV3StakerAddress,\n} from 'constants/ethContractAddresses'\nimport { FarmData, V3Farm } from 'constants/v3Farms'\nimport nftPositionManagerAbi from 'index-sdk/abi/NftPositionManager.json'\nimport uniswapV3FactoryAbi from 'index-sdk/abi/uniswapV3Factory.json'\nimport uniswapV3StakerAbi from 'index-sdk/abi/uniswapV3Staker.json'\nimport BigNumber from 'utils/bignumber'\n\n/**\n * Returns all NFTs eligible for the target farm for the target user account.\n * These are effectively all unstaked NFT IDs.\n * @param farm - Target farm to check NFTs against\n * @param user - User's ethereum account\n * @param provider - Ethereum network provider\n * @returns - A list of NFT IDs\n */\nexport async function getValidIds(\n  farm: V3Farm,\n  user: string,\n  provider: provider\n): Promise<number[]> {\n  const nftPositionManager = getNftPositionManager(provider)\n  const factory = getFactory(provider)\n\n  const totalNfts = await nftPositionManager.methods.balanceOf(user).call()\n\n  const validIds: number[] = []\n  for (let i = 0; i < totalNfts; i++) {\n    const tokenId = await nftPositionManager.methods\n      .tokenOfOwnerByIndex(user, i)\n      .call()\n    // check if this NFT is an LP for a currently active farm\n    if (\n      await isTokenFromValidPool(tokenId, farm, nftPositionManager, factory)\n    ) {\n      validIds.push(tokenId)\n    }\n  }\n\n  return validIds\n}\n\nexport async function depositAndStake(\n  nftId: number,\n  farm: V3Farm,\n  user: string,\n  provider: provider\n): Promise<string | null> {\n  const nftPositionManager = getNftPositionManager(provider)\n\n  const stakeTokenType = {\n    IncentiveKey: {\n      rewardToken: 'address',\n      pool: 'address',\n      startTime: 'uint256',\n      endTime: 'uint256',\n      refundee: 'address',\n    },\n  }\n\n  const currentFarmNumber = getMostRecentFarmNumber(farm)\n\n  const data = new Web3(provider).eth.abi.encodeParameters(\n    [stakeTokenType],\n    [farm.farms[currentFarmNumber]]\n  )\n\n  // add initially staked farms in transfer data\n  return new Promise((resolve) => {\n    nftPositionManager.methods\n      .safeTransferFrom(user, uniswapV3StakerAddress, nftId, data)\n      .send({ from: user })\n      .on('transactionHash', (txId: string) => {\n        if (!txId) resolve(null)\n\n        resolve(txId)\n      })\n      .on('error', (error: any) => {\n        console.log(error)\n        resolve(null)\n      })\n  })\n}\n\nexport async function withdraw(\n  nftId: number,\n  user: string,\n  farm: V3Farm,\n  provider: provider\n): Promise<string | null> {\n  const stakingContract = getStakingContract(provider)\n\n  const stakedFarmIds = await getCurrentStakes(farm, nftId, provider)\n\n  const data: string[] = await Promise.all(\n    stakedFarmIds.map(async (farmId) => {\n      return stakingContract.methods\n        .unstakeToken(farm.farms[farmId], nftId)\n        .encodeABI()\n    })\n  )\n\n  data.push(\n    stakingContract.methods.withdrawToken(nftId, user, '0x').encodeABI()\n  )\n\n  return new Promise((resolve) => {\n    stakingContract.methods\n      .multicall(data)\n      .send({ from: user })\n      .on('transactionHash', (txId: string) => {\n        if (!txId) resolve(null)\n\n        resolve(txId)\n      })\n      .on('error', (error: any) => {\n        console.log(error)\n        resolve(null)\n      })\n  })\n}\n\nexport async function getAccruedRewardsAmount(\n  user: string,\n  rewardToken: string,\n  provider: provider\n): Promise<BigNumber> {\n  const stakingContract = getStakingContract(provider)\n  return await stakingContract.methods.rewards(rewardToken, user).call()\n}\n\nexport async function getAllPendingRewardsAmount(\n  user: string,\n  farm: V3Farm,\n  provider: provider\n): Promise<BigNumber> {\n  const stakingContract = getStakingContract(provider)\n  const deposits = await getAllDepositedTokens(user, farm, provider)\n\n  const amounts = await Promise.all(\n    deposits.map(async (id) => {\n      const stakes = await getCurrentStakes(farm, id, provider)\n\n      const amounts = await Promise.all(\n        stakes.map(async (farmNumber) => {\n          const rewardInfo = await stakingContract.methods\n            .getRewardInfo(farm.farms[farmNumber], id)\n            .call()\n\n          return new BigNumber(rewardInfo.reward)\n        })\n      )\n\n      return amounts.reduce((a, b) => {\n        return a.plus(b)\n      }, new BigNumber(0))\n    })\n  )\n\n  return amounts.reduce((a, b) => {\n    return a.plus(b)\n  }, new BigNumber(0))\n}\n\nexport type FarmReward = {\n  farm: number\n  rewards: BigNumber\n}\n\nexport async function getIndividualPendingRewardsAmount(\n  user: string,\n  farm: V3Farm,\n  nftId: number,\n  provider: provider\n): Promise<BigNumber> {\n  const stakingContract = getStakingContract(provider)\n\n  const stakes = await getCurrentStakes(farm, nftId, provider)\n\n  const pendingRewards = await Promise.all(\n    stakes.map(async (farmNumber) => {\n      const rewardInfo = await stakingContract.methods\n        .getRewardInfo(farm.farms[farmNumber], nftId)\n        .call()\n\n      return new BigNumber(rewardInfo.reward)\n    })\n  )\n\n  return pendingRewards.reduce((a, b) => {\n    return a.plus(b)\n  }, new BigNumber(0))\n}\n\nexport async function claimAccruedRewards(\n  user: string,\n  rewardToken: string,\n  provider: provider\n): Promise<string | null> {\n  const stakingContract = getStakingContract(provider)\n  return new Promise((resolve) => {\n    stakingContract.methods\n      .claimReward(rewardToken, user, 0)\n      .send({ from: user })\n      .on('transactionHash', (txId: string) => {\n        if (!txId) resolve(null)\n\n        resolve(txId)\n      })\n      .on('error', (error: any) => {\n        console.log(error)\n        resolve(null)\n      })\n  })\n}\n\nexport async function getAllDepositedTokens(\n  user: string,\n  farm: V3Farm,\n  provider: provider\n): Promise<number[]> {\n  const options = {\n    fromBlock: 0,\n    toBlock: 'latest',\n    filter: {\n      from: user,\n      to: uniswapV3StakerAddress || '',\n    },\n  }\n\n  const nftPositionManager = getNftPositionManager(provider)\n  const stakingContract = getStakingContract(provider)\n  const factory = getFactory(provider)\n\n  const tokenIdsPotentialDuplicates = (\n    await nftPositionManager.getPastEvents('Transfer', options)\n  ).map((event) => event.returnValues['tokenId'])\n  const tokenIds = Array.from(new Set(tokenIdsPotentialDuplicates))\n\n  const currentlyDeposited: number[] = []\n  for (let i = 0; i < tokenIds.length; i++) {\n    const depositInfo = await stakingContract.methods\n      .deposits(tokenIds[i])\n      .call()\n    const isValidPoolToken = await isTokenFromValidPool(\n      tokenIds[i],\n      farm,\n      nftPositionManager,\n      factory\n    )\n\n    if (\n      isValidPoolToken &&\n      (depositInfo.tickLower !== '0' || depositInfo.tickUpper !== '0')\n    ) {\n      currentlyDeposited.push(parseInt(tokenIds[i]))\n    }\n  }\n\n  return currentlyDeposited\n}\n\n// Helper functions\n\nexport function getMostRecentFarmNumber(farm: V3Farm): number {\n  return farm.farms.length - 1\n}\n\nasync function getCurrentStakes(\n  farm: V3Farm,\n  nftId: number,\n  provider: provider\n): Promise<number[]> {\n  const stakingContract = getStakingContract(provider)\n  const currentStakes = []\n\n  for (let i = 0; i < farm.farms.length; i++) {\n    const incentiveId = deriveIncentiveId(provider, farm.farms[i])\n    const stakeInfo = await stakingContract.methods\n      .stakes(nftId, incentiveId)\n      .call()\n\n    if (stakeInfo.liquidity !== '0') {\n      currentStakes.push(i)\n    }\n  }\n\n  return currentStakes\n}\n\nfunction getNftPositionManager(provider: provider) {\n  const web3 = new Web3(provider)\n\n  return new web3.eth.Contract(\n    nftPositionManagerAbi as unknown as AbiItem,\n    nftPositionManagerAddress\n  )\n}\n\nfunction getFactory(provider: provider) {\n  const web3 = new Web3(provider)\n\n  return new web3.eth.Contract(\n    uniswapV3FactoryAbi as unknown as AbiItem,\n    uniswapV3FactoryAddress\n  )\n}\n\nfunction getStakingContract(provider: provider) {\n  const web3 = new Web3(provider)\n\n  return new web3.eth.Contract(\n    uniswapV3StakerAbi as unknown as AbiItem,\n    uniswapV3StakerAddress\n  )\n}\n\nfunction deriveIncentiveId(provider: provider, farmPlot: FarmData) {\n  const stakeTokenType = {\n    IncentiveKey: {\n      rewardToken: 'address',\n      pool: 'address',\n      startTime: 'uint256',\n      endTime: 'uint256',\n      refundee: 'address',\n    },\n  }\n\n  const data = new Web3(provider).eth.abi.encodeParameters(\n    [stakeTokenType],\n    [farmPlot]\n  )\n\n  return Web3.utils.keccak256(data)\n}\n\nasync function isTokenFromValidPool(\n  tokenId: number,\n  farm: V3Farm,\n  nftPositionManager: any,\n  factory: any\n): Promise<boolean> {\n  const position = await nftPositionManager.methods.positions(tokenId).call()\n  const nftPoolAddress = await factory.methods\n    .getPool(position.token0, position.token1, position.fee)\n    .call()\n\n  return farm.pool?.toLowerCase() === nftPoolAddress?.toLowerCase()\n}\n\nexport const getUpcomingFarms = (farm: V3Farm) => {\n  return farm.farms.filter((farm: FarmData) => {\n    const now = Date.now()\n    const formattedStartTime = farm.startTime * 1000\n\n    return now < formattedStartTime\n  })\n}\n\nexport const getActiveFarms = (farm: V3Farm) => {\n  return farm.farms.filter((farm: FarmData) => {\n    const now = Date.now()\n    const formattedStartTime = farm.startTime * 1000\n    const formattedEndTime = farm.endTime * 1000\n\n    return now > formattedStartTime && now < formattedEndTime\n  })\n}\n\nexport const getExpiredFarms = (farm: V3Farm) => {\n  return farm.farms.filter((farm: FarmData) => {\n    const now = Date.now()\n    const formattedEndTime = farm.endTime * 1000\n\n    return now > formattedEndTime\n  })\n}\n"]},"metadata":{},"sourceType":"module"}