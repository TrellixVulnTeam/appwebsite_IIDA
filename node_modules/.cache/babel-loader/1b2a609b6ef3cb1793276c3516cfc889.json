{"ast":null,"code":"import Web3ProviderEngine from 'web3-provider-engine';\nimport TransportWebUSB from '@ledgerhq/hw-transport-webusb';\nimport { AbstractConnector } from '@web3-react/abstract-connector';\nimport { createLedgerSubprovider } from './ledgerSubprovider';\n\nconst RpcSubprovider = require('web3-provider-engine/subproviders/rpc.js');\n\nconst CacheSubprovider = require('web3-provider-engine/subproviders/cache');\n\nconst FiltersSubprovider = require('web3-provider-engine/subproviders/filters.js');\n\nconst NonceSubprovider = require('web3-provider-engine/subproviders/nonce-tracker.js');\n\nconst WsSubprovider = require('web3-provider-engine/subproviders/websocket');\n\nexport class LedgerConnector extends AbstractConnector {\n  constructor(chainId, rpcUrl, wsUrl, baseDerivationPath = \"44'/60'/0'/0/0\") {\n    super({\n      supportedChainIds: [chainId]\n    });\n    this.chainId = chainId;\n    this.provider = void 0;\n    this.ledger = void 0;\n    this.provider = new Web3ProviderEngine();\n    this.provider.addProvider(new FiltersSubprovider());\n    this.provider.addProvider(new NonceSubprovider());\n    this.provider.addProvider(new CacheSubprovider());\n\n    const transport = () => TransportWebUSB.create();\n\n    this.ledger = createLedgerSubprovider(transport, {\n      networkId: chainId,\n      paths: [baseDerivationPath]\n    });\n    this.provider.addProvider(this.ledger); // TODO: standardised ws endpoint?\n    // WS is required to retrieve balances\n\n    this.provider.addProvider(new WsSubprovider({\n      rpcUrl: wsUrl\n    }));\n    this.provider.addProvider(new RpcSubprovider({\n      rpcUrl\n    }));\n  }\n\n  async activate() {\n    // Only start the provider on activation. The engine will start\n    // polling the blockchain.\n    this.provider.start();\n    return {\n      provider: this.provider,\n      chainId: this.chainId\n    };\n  }\n\n  async getProvider() {\n    return this.provider;\n  }\n\n  async getChainId() {\n    return this.chainId;\n  }\n\n  async getAccount() {\n    // getAccounts is a callback. See HookedWalletSubprovider from\n    // metamask. We wrap the callback in a promise and return it.\n    return new Promise((resolve, reject) => {\n      this.ledger.getAccounts((err, res) => {\n        if (err != null) {\n          reject(err);\n        } else {\n          if (!res.length) {\n            reject('no accounts found');\n          }\n\n          resolve(res[0]);\n        }\n      });\n    });\n  }\n\n  deactivate() {\n    this.provider.stop();\n  }\n\n}","map":{"version":3,"sources":["/Users/safahi/Desktop/index-ui-master/src/utils/ledgerConnector.ts"],"names":["Web3ProviderEngine","TransportWebUSB","AbstractConnector","createLedgerSubprovider","RpcSubprovider","require","CacheSubprovider","FiltersSubprovider","NonceSubprovider","WsSubprovider","LedgerConnector","constructor","chainId","rpcUrl","wsUrl","baseDerivationPath","supportedChainIds","provider","ledger","addProvider","transport","create","networkId","paths","activate","start","getProvider","getChainId","getAccount","Promise","resolve","reject","getAccounts","err","res","length","deactivate","stop"],"mappings":"AAAA,OAAOA,kBAAP,MAA+B,sBAA/B;AAGA,OAAOC,eAAP,MAA4B,+BAA5B;AACA,SAASC,iBAAT,QAAkC,gCAAlC;AAGA,SAASC,uBAAT,QAAwC,qBAAxC;;AAEA,MAAMC,cAAc,GAAGC,OAAO,CAAC,0CAAD,CAA9B;;AACA,MAAMC,gBAAgB,GAAGD,OAAO,CAAC,yCAAD,CAAhC;;AACA,MAAME,kBAAkB,GAAGF,OAAO,CAAC,8CAAD,CAAlC;;AACA,MAAMG,gBAAgB,GAAGH,OAAO,CAAC,oDAAD,CAAhC;;AACA,MAAMI,aAAa,GAAGJ,OAAO,CAAC,6CAAD,CAA7B;;AAEA,OAAO,MAAMK,eAAN,SAA8BR,iBAA9B,CAAgD;AAIrDS,EAAAA,WAAW,CACQC,OADR,EAETC,MAFS,EAGTC,KAHS,EAITC,kBAA0B,GAAG,gBAJpB,EAKT;AACA,UAAM;AAAEC,MAAAA,iBAAiB,EAAE,CAACJ,OAAD;AAArB,KAAN;AADA,SAJiBA,OAIjB,GAJiBA,OAIjB;AAAA,SAReK,QAQf;AAAA,SAPeC,MAOf;AAEA,SAAKD,QAAL,GAAgB,IAAIjB,kBAAJ,EAAhB;AACA,SAAKiB,QAAL,CAAcE,WAAd,CAA0B,IAAIZ,kBAAJ,EAA1B;AACA,SAAKU,QAAL,CAAcE,WAAd,CAA0B,IAAIX,gBAAJ,EAA1B;AACA,SAAKS,QAAL,CAAcE,WAAd,CAA0B,IAAIb,gBAAJ,EAA1B;;AACA,UAAMc,SAAS,GAAG,MAAMnB,eAAe,CAACoB,MAAhB,EAAxB;;AACA,SAAKH,MAAL,GAAcf,uBAAuB,CAACiB,SAAD,EAAY;AAC/CE,MAAAA,SAAS,EAAEV,OADoC;AAE/CW,MAAAA,KAAK,EAAE,CAACR,kBAAD;AAFwC,KAAZ,CAArC;AAIA,SAAKE,QAAL,CAAcE,WAAd,CAA0B,KAAKD,MAA/B,EAXA,CAYA;AACA;;AACA,SAAKD,QAAL,CAAcE,WAAd,CAA0B,IAAIV,aAAJ,CAAkB;AAAEI,MAAAA,MAAM,EAAEC;AAAV,KAAlB,CAA1B;AACA,SAAKG,QAAL,CAAcE,WAAd,CAA0B,IAAIf,cAAJ,CAAmB;AAAES,MAAAA;AAAF,KAAnB,CAA1B;AACD;;AAEa,QAARW,QAAQ,GAA8C;AAC1D;AACA;AACA,SAAKP,QAAL,CAAcQ,KAAd;AACA,WAAO;AAAER,MAAAA,QAAQ,EAAE,KAAKA,QAAjB;AAA2BL,MAAAA,OAAO,EAAE,KAAKA;AAAzC,KAAP;AACD;;AAEgB,QAAXc,WAAW,GAAgC;AAC/C,WAAO,KAAKT,QAAZ;AACD;;AAEe,QAAVU,UAAU,GAA6B;AAC3C,WAAO,KAAKf,OAAZ;AACD;;AAEe,QAAVgB,UAAU,GAAoB;AAClC;AACA;AACA,WAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtC,WAAKb,MAAL,CAAYc,WAAZ,CAAwB,CAACC,GAAD,EAAaC,GAAb,KAA+B;AACrD,YAAID,GAAG,IAAI,IAAX,EAAiB;AACfF,UAAAA,MAAM,CAACE,GAAD,CAAN;AACD,SAFD,MAEO;AACL,cAAI,CAACC,GAAG,CAACC,MAAT,EAAiB;AACfJ,YAAAA,MAAM,CAAC,mBAAD,CAAN;AACD;;AACDD,UAAAA,OAAO,CAACI,GAAG,CAAC,CAAD,CAAJ,CAAP;AACD;AACF,OATD;AAUD,KAXM,CAAP;AAYD;;AAEDE,EAAAA,UAAU,GAAS;AACjB,SAAKnB,QAAL,CAAcoB,IAAd;AACD;;AA7DoD","sourcesContent":["import Web3ProviderEngine from 'web3-provider-engine'\nimport HookedWalletSubprovider from 'web3-provider-engine/subproviders/hooked-wallet'\n\nimport TransportWebUSB from '@ledgerhq/hw-transport-webusb'\nimport { AbstractConnector } from '@web3-react/abstract-connector'\nimport { ConnectorUpdate } from '@web3-react/types'\n\nimport { createLedgerSubprovider } from './ledgerSubprovider'\n\nconst RpcSubprovider = require('web3-provider-engine/subproviders/rpc.js')\nconst CacheSubprovider = require('web3-provider-engine/subproviders/cache')\nconst FiltersSubprovider = require('web3-provider-engine/subproviders/filters.js')\nconst NonceSubprovider = require('web3-provider-engine/subproviders/nonce-tracker.js')\nconst WsSubprovider = require('web3-provider-engine/subproviders/websocket')\n\nexport class LedgerConnector extends AbstractConnector {\n  private readonly provider: Web3ProviderEngine\n  private readonly ledger: HookedWalletSubprovider\n\n  constructor(\n    private readonly chainId: number,\n    rpcUrl: string,\n    wsUrl: string,\n    baseDerivationPath: string = \"44'/60'/0'/0/0\"\n  ) {\n    super({ supportedChainIds: [chainId] })\n    this.provider = new Web3ProviderEngine()\n    this.provider.addProvider(new FiltersSubprovider())\n    this.provider.addProvider(new NonceSubprovider())\n    this.provider.addProvider(new CacheSubprovider())\n    const transport = () => TransportWebUSB.create()\n    this.ledger = createLedgerSubprovider(transport, {\n      networkId: chainId,\n      paths: [baseDerivationPath],\n    })\n    this.provider.addProvider(this.ledger)\n    // TODO: standardised ws endpoint?\n    // WS is required to retrieve balances\n    this.provider.addProvider(new WsSubprovider({ rpcUrl: wsUrl }))\n    this.provider.addProvider(new RpcSubprovider({ rpcUrl }))\n  }\n\n  async activate(): Promise<ConnectorUpdate<string | number>> {\n    // Only start the provider on activation. The engine will start\n    // polling the blockchain.\n    this.provider.start()\n    return { provider: this.provider, chainId: this.chainId }\n  }\n\n  async getProvider(): Promise<Web3ProviderEngine> {\n    return this.provider\n  }\n\n  async getChainId(): Promise<string | number> {\n    return this.chainId\n  }\n\n  async getAccount(): Promise<string> {\n    // getAccounts is a callback. See HookedWalletSubprovider from\n    // metamask. We wrap the callback in a promise and return it.\n    return new Promise((resolve, reject) => {\n      this.ledger.getAccounts((err: Error, res: string[]) => {\n        if (err != null) {\n          reject(err)\n        } else {\n          if (!res.length) {\n            reject('no accounts found')\n          }\n          resolve(res[0])\n        }\n      })\n    })\n  }\n\n  deactivate(): void {\n    this.provider.stop()\n  }\n}\n"]},"metadata":{},"sourceType":"module"}