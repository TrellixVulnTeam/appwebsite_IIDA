{"ast":null,"code":"import { Transaction as EthereumTx } from 'ethereumjs-tx';\nimport HookedWalletSubprovider from 'web3-provider-engine/subproviders/hooked-wallet';\nimport AppEth from '@ledgerhq/hw-app-eth';\n\nconst stripHexPrefix = str => str.slice(0, 2) === '0x' ? str.slice(2) : str;\n\nconst makeError = (msg, id) => {\n  const err = new Error(msg); // @ts-ignore\n\n  err.id = id;\n  return err;\n};\n\nconst defaultOptions = {\n  networkId: 1,\n  // mainnet\n  paths: [\"44'/60'/x'/0/0\", \"44'/60'/0'/x\"],\n  // ledger live derivation path\n  askConfirm: false,\n  accountsLength: 1,\n  accountsOffset: 0\n}; // 'Inspired' by https://gitlab.com/jarvis-network/base/libraries/js/ledger-web3-provider/-/tree/master\n\nexport const createLedgerSubprovider = (getTransport, options) => {\n  const {\n    networkId,\n    paths,\n    askConfirm,\n    accountsLength,\n    accountsOffset\n  } = { ...defaultOptions,\n    ...options\n  };\n\n  if (!paths.length) {\n    throw new Error('paths must not be empty');\n  }\n\n  const addressToPathMap = {};\n\n  const getAccountsAsync = async () => {\n    const transport = await getTransport();\n\n    try {\n      const eth = new AppEth(transport);\n      const addresses = {};\n\n      for (let i = accountsOffset; i < accountsOffset + accountsLength; i++) {\n        const x = Math.floor(i / paths.length);\n        const pathIndex = i - paths.length * x;\n        const path = paths[pathIndex].replace('x', String(x));\n        const response = await eth.getAddress(path, askConfirm, true);\n        addresses[path] = response.address;\n        addressToPathMap[response.address.toLowerCase()] = path;\n      }\n\n      return addresses;\n    } finally {\n      transport.close();\n    }\n  };\n\n  const signPersonalMessageAsync = async ({\n    from,\n    data\n  }) => {\n    const path = addressToPathMap[from.toLowerCase()];\n    if (!path) throw new Error(\"address unknown '\" + from + \"'\");\n    const transport = await getTransport();\n\n    try {\n      const eth = new AppEth(transport);\n      const result = await eth.signPersonalMessage(path, stripHexPrefix(data));\n      const v = parseInt(result.v.toString(), 10) - 27;\n      let vHex = v.toString(16);\n\n      if (vHex.length < 2) {\n        vHex = `0${v}`;\n      }\n\n      return `0x${result.r}${result.s}${vHex}`;\n    } finally {\n      transport.close();\n    }\n  };\n\n  const signTransactionAsync = async txData => {\n    const path = addressToPathMap[txData.from.toLowerCase()];\n\n    if (!path) {\n      throw new Error(\"address unknown '\" + txData.from + \"'\");\n    }\n\n    const transport = await getTransport();\n\n    try {\n      const eth = new AppEth(transport);\n      const tx = new EthereumTx(txData, {\n        chain: networkId\n      }); // Set the EIP155 bits\n\n      tx.raw[6] = Buffer.from([networkId]); // v\n\n      tx.raw[7] = Buffer.from([]); // r\n\n      tx.raw[8] = Buffer.from([]); // s\n      // Pass hex-rlp to ledger for signing\n\n      const result = await eth.signTransaction(path, tx.serialize().toString('hex')); // Store signature in transaction\n\n      tx.v = Buffer.from(result.v, 'hex');\n      tx.r = Buffer.from(result.r, 'hex');\n      tx.s = Buffer.from(result.s, 'hex'); // EIP155: v should be chain_id * 2 + {35, 36}\n\n      const signedChainId = Math.floor((tx.v[0] - 35) / 2);\n      const validChainId = networkId & 0xff; // FIXME this is to fixed a current workaround that app don't support > 0xff\n\n      if (signedChainId !== validChainId) {\n        throw makeError('Invalid networkId signature returned. Expected: ' + networkId + ', Got: ' + signedChainId, 'InvalidNetworkId');\n      }\n\n      return `0x${tx.serialize().toString('hex')}`;\n    } finally {\n      transport.close();\n    }\n  };\n\n  return new HookedWalletSubprovider({\n    getAccounts: cb => {\n      getAccountsAsync().then(res => cb(undefined, Object.values(res))).catch(err => cb(err, null));\n    },\n    signTransaction: (txData, cb) => {\n      signTransactionAsync(txData).then(res => cb(undefined, res)).catch(err => cb(err, null));\n    },\n    signPersonalMessage: (txData, cb) => {\n      signPersonalMessageAsync(txData).then(res => cb(undefined, res)).catch(err => cb(err, null));\n    }\n  });\n};","map":{"version":3,"sources":["/Users/safahi/Desktop/index-ui-master/src/utils/ledgerSubprovider.ts"],"names":["Transaction","EthereumTx","HookedWalletSubprovider","AppEth","stripHexPrefix","str","slice","makeError","msg","id","err","Error","defaultOptions","networkId","paths","askConfirm","accountsLength","accountsOffset","createLedgerSubprovider","getTransport","options","length","addressToPathMap","getAccountsAsync","transport","eth","addresses","i","x","Math","floor","pathIndex","path","replace","String","response","getAddress","address","toLowerCase","close","signPersonalMessageAsync","from","data","result","signPersonalMessage","v","parseInt","toString","vHex","r","s","signTransactionAsync","txData","tx","chain","raw","Buffer","signTransaction","serialize","signedChainId","validChainId","getAccounts","cb","then","res","undefined","Object","values","catch"],"mappings":"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","sourcesContent":["import { Transaction as EthereumTx } from 'ethereumjs-tx'\nimport HookedWalletSubprovider from 'web3-provider-engine/subproviders/hooked-wallet'\n\nimport AppEth from '@ledgerhq/hw-app-eth'\nimport Transport from '@ledgerhq/hw-transport'\n\nconst stripHexPrefix = (str: string) =>\n  str.slice(0, 2) === '0x' ? str.slice(2) : str\n\nconst makeError = (msg: string, id: string) => {\n  const err = new Error(msg)\n  // @ts-ignore\n  err.id = id\n  return err\n}\n\ninterface SubproviderOptions {\n  // refer to https://github.com/ethereum/EIPs/blob/master/EIPS/eip-155.md\n  networkId: number\n  // derivation path schemes (with a x in the path)\n  paths?: string[]\n  // should use actively validate on the device\n  askConfirm?: boolean\n  // number of accounts to derivate\n  accountsLength?: number\n  // offset index to use to start derivating the accounts\n  accountsOffset?: number\n}\n\nconst defaultOptions = {\n  networkId: 1, // mainnet\n  paths: [\"44'/60'/x'/0/0\", \"44'/60'/0'/x\"], // ledger live derivation path\n  askConfirm: false,\n  accountsLength: 1,\n  accountsOffset: 0,\n}\n\n// 'Inspired' by https://gitlab.com/jarvis-network/base/libraries/js/ledger-web3-provider/-/tree/master\nexport const createLedgerSubprovider = (\n  getTransport: () => Promise<Transport>,\n  options?: SubproviderOptions\n): HookedWalletSubprovider => {\n  const { networkId, paths, askConfirm, accountsLength, accountsOffset } = {\n    ...defaultOptions,\n    ...options,\n  }\n\n  if (!paths.length) {\n    throw new Error('paths must not be empty')\n  }\n\n  const addressToPathMap: Record<string, string> = {}\n\n  const getAccountsAsync = async (): Promise<Record<string, string>> => {\n    const transport = await getTransport()\n    try {\n      const eth = new AppEth(transport)\n      const addresses: Record<string, string> = {}\n      for (let i = accountsOffset; i < accountsOffset + accountsLength; i++) {\n        const x = Math.floor(i / paths.length)\n        const pathIndex = i - paths.length * x\n        const path = paths[pathIndex].replace('x', String(x))\n        const response = await eth.getAddress(path, askConfirm, true)\n        addresses[path] = response.address\n        addressToPathMap[response.address.toLowerCase()] = path\n      }\n      return addresses\n    } finally {\n      transport.close()\n    }\n  }\n\n  type TxParams = { from: string; data: string }\n\n  const signPersonalMessageAsync = async ({\n    from,\n    data,\n  }: TxParams): Promise<string> => {\n    const path = addressToPathMap[from.toLowerCase()]\n    if (!path) throw new Error(\"address unknown '\" + from + \"'\")\n    const transport = await getTransport()\n    try {\n      const eth = new AppEth(transport)\n      const result = await eth.signPersonalMessage(path, stripHexPrefix(data))\n      const v = parseInt(result.v.toString(), 10) - 27\n      let vHex = v.toString(16)\n      if (vHex.length < 2) {\n        vHex = `0${v}`\n      }\n      return `0x${result.r}${result.s}${vHex}`\n    } finally {\n      transport.close()\n    }\n  }\n\n  const signTransactionAsync = async (txData: TxParams): Promise<string> => {\n    const path = addressToPathMap[txData.from.toLowerCase()]\n    if (!path) {\n      throw new Error(\"address unknown '\" + txData.from + \"'\")\n    }\n    const transport = await getTransport()\n    try {\n      const eth = new AppEth(transport)\n      const tx = new EthereumTx(txData, { chain: networkId })\n\n      // Set the EIP155 bits\n      tx.raw[6] = Buffer.from([networkId]) // v\n      tx.raw[7] = Buffer.from([]) // r\n      tx.raw[8] = Buffer.from([]) // s\n\n      // Pass hex-rlp to ledger for signing\n      const result = await eth.signTransaction(\n        path,\n        tx.serialize().toString('hex')\n      )\n\n      // Store signature in transaction\n      tx.v = Buffer.from(result.v, 'hex')\n      tx.r = Buffer.from(result.r, 'hex')\n      tx.s = Buffer.from(result.s, 'hex')\n\n      // EIP155: v should be chain_id * 2 + {35, 36}\n      const signedChainId = Math.floor((tx.v[0] - 35) / 2)\n      const validChainId = networkId & 0xff // FIXME this is to fixed a current workaround that app don't support > 0xff\n      if (signedChainId !== validChainId) {\n        throw makeError(\n          'Invalid networkId signature returned. Expected: ' +\n            networkId +\n            ', Got: ' +\n            signedChainId,\n          'InvalidNetworkId'\n        )\n      }\n\n      return `0x${tx.serialize().toString('hex')}`\n    } finally {\n      transport.close()\n    }\n  }\n\n  type Callback = (error?: Error, result?: any) => any\n\n  return new HookedWalletSubprovider({\n    getAccounts: (cb: Callback) => {\n      getAccountsAsync()\n        .then((res) => cb(undefined, Object.values(res)))\n        .catch((err) => cb(err, null))\n    },\n    signTransaction: (txData: TxParams, cb: Callback) => {\n      signTransactionAsync(txData)\n        .then((res) => cb(undefined, res))\n        .catch((err) => cb(err, null))\n    },\n    signPersonalMessage: (txData: TxParams, cb: Callback) => {\n      signPersonalMessageAsync(txData)\n        .then((res) => cb(undefined, res))\n        .catch((err) => cb(err, null))\n    },\n  })\n}\n"]},"metadata":{},"sourceType":"module"}