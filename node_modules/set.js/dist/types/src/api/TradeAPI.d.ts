import { ContractTransaction } from 'ethers';
import { Provider } from '@ethersproject/providers';
import { Address } from '@setprotocol/set-protocol-v2/utils/types';
import { TransactionOverrides } from '@setprotocol/set-protocol-v2/dist/typechain';
import { BigNumber } from 'ethers/lib/ethers';
import SetTokenAPI from './SetTokenAPI';
import { TradeQuote, CoinGeckoTokenData, CoinGeckoTokenMap, GasOracleSpeed, CoinGeckoCoinPrices } from '../types';
/**
 * @title  TradeAPI
 * @author Set Protocol
 *
 * The TradeAPI exposes methods to generate the calldata needed for 1inch exchange trades
 * and a simple trade interface for making the actual trades.
 *
 */
export default class TradeAPI {
    private tradeModuleWrapper;
    private assert;
    private provider;
    private tradeQuoter;
    private coinGecko;
    private chainId;
    constructor(provider: Provider, tradeModuleAddress: Address, zeroExApiKey?: string);
    /**
     * Initializes this TradeModule to the SetToken. Only callable by the SetToken's manager.
     *
     * @param setTokenAddress             Address of the SetToken to initialize
     * @param callerAddress               Address of caller (optional)
     * @param txOpts                      Overrides for transaction (optional)
     *
     * @return                            Transaction hash of the initialize transaction
     */
    initializeAsync(setTokenAddress: Address, callerAddress?: Address, txOpts?: TransactionOverrides): Promise<ContractTransaction>;
    /**
     * Executes a trade on a supported DEX. Only callable by the SetToken's manager.
     *
     * @dev Although the SetToken units are passed in for the send and receive quantities, the total quantity
     * sent and received is the quantity of SetToken units multiplied by the SetToken totalSupply.
     *
     * @param setTokenAddress             Instance of the SetToken to trade
     * @param exchangeName                Human readable name of the exchange in the integrations registry
     * @param sendTokenAddress            Address of the token to be sent to the exchange
     * @param sendQuantity                Units of token in SetToken sent to the exchange
     * @param receiveTokenAddress         Address of the token that will be received from the exchange
     * @param minReceiveQuantity          Min units of token in SetToken to be received from the exchange
     * @param data                        Arbitrary bytes to be used to construct trade call data
     *
     * @return                            Transaction hash of the trade transaction
     */
    tradeAsync(setTokenAddress: Address, exchangeName: string, sendTokenAddress: Address, sendQuantity: BigNumber, receiveTokenAddress: Address, minReceivedQuantity: BigNumber, data: string, callerAddress?: Address, txOpts?: TransactionOverrides): Promise<ContractTransaction>;
    /**
     * Call 0x API to generate a trade quote for two SetToken components.
     *
     * @param  fromToken            Address of token being sold
     * @param  toToken              Address of token being bought
     * @param  fromTokenDecimals    Token decimals of token being sold (ex: 18)
     * @param  toTokenDecimals      Token decimals of token being bought (ex: 18)
     * @param  rawAmount            String quantity of token to sell (ex: "0.5")
     * @param  fromAddress          SetToken address which holds the buy / sell components
     * @param  setToken             SetTokenAPI instance
     * @param  gasPrice             (Optional) gasPrice to calculate gas costs with (Default: fetched from EthGasStation)
     * @param  slippagePercentage   (Optional) maximum slippage, determines min receive quantity. (Default: 2%)
     * @param  isFirmQuote          (Optional) Whether quote request is indicative or firm
     * @param  feePercentage        (Optional) Default: 0
     * @param  feeRecipient         (Optional) Default: 0xD3D555Bb655AcBA9452bfC6D7cEa8cC7b3628C55
     * @param  excludedSources      (Optional) Exchanges to exclude (Default: ['Kyber', 'Eth2Dai', 'Uniswap', 'Mesh'])
     *
     * @return {Promise<TradeQuote>}
     */
    fetchTradeQuoteAsync(fromToken: Address, toToken: Address, fromTokenDecimals: number, toTokenDecimals: number, rawAmount: string, fromAddress: Address, setToken: SetTokenAPI, gasPrice?: number, slippagePercentage?: number, isFirmQuote?: boolean, feePercentage?: number, feeRecipient?: Address, excludedSources?: string[]): Promise<TradeQuote>;
    /**
     * Fetches a list of tokens and their metadata from CoinGecko. Each entry includes
     * the token's address, proper name, decimals, exchange symbol and a logo URI if available.
     * For Ethereum, this is a list of tokens tradeable on Uniswap, for Polygon it's a list of
     * tokens tradeable on Sushiswap's Polygon exchange. Method is useful for acquiring token decimals
     * necessary to generate a trade quote and images for representing available tokens in a UI.
     *
     * @return List of tradeable tokens for chain platform
     */
    fetchTokenListAsync(): Promise<CoinGeckoTokenData[]>;
    /**
     * Fetches the same info as `fetchTokenList` in the form of a map indexed by address. Method is
     * useful if you're cacheing the token list and want quick lookups for a variety of trades.
     *
     * @return Map of token addresses to token metadata
     */
    fetchTokenMapAsync(): Promise<CoinGeckoTokenMap>;
    /**
     * Fetches a list of prices vs currencies for the specified inputs from CoinGecko
     *
     * @param  contractAddresses         String array of contract addresses
     * @param  vsCurrencies              String array of currency codes (see CoinGecko api for a complete list)
     *
     * @return                           List of prices vs currencies
     */
    fetchCoinPricesAsync(contractAddresses: string[], vsCurrencies: string[]): Promise<CoinGeckoCoinPrices>;
    /**
     * Fetches the recommended gas price for a specified execution speed.
     *
     * @param  speed                   (Optional) string value: "average" | "fast" | "fastest" (Default: fast)
     *
     * @return                         Number: gas price
     */
    fetchGasPriceAsync(speed?: GasOracleSpeed): Promise<number>;
    private initializeForChain;
}
