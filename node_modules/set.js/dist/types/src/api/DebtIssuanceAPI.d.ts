import { ContractTransaction } from 'ethers';
import { Provider } from '@ethersproject/providers';
import { Address } from '@setprotocol/set-protocol-v2/utils/types';
import { TransactionOverrides } from '@setprotocol/set-protocol-v2/dist/typechain';
import { BigNumber } from 'ethers/lib/ethers';
import Assertions from '../assertions';
/**
 * @title  DebtIssuanceAPI
 * @author Set Protocol
 *
 * The DebtIssuanceModuleAPI exposes issue and redeem functionality that contain default and all
 * external positions, including debt positions. Module hooks are added to allow for syncing of positions, and component
 * level hooks are added to ensure positions are replicated correctly. The manager can define arbitrary issuance logic
 * in the manager hook, as well as specify issue and redeem fees.
 *
 */
export default class DebtIssuanceAPI {
    private debtIssuanceModuleWrapper;
    private assert;
    constructor(provider: Provider, debtIssuanceModuleAddress: Address, assertions?: Assertions);
    /**
     * Initializes the DebtIssuanceModule to the SetToken. Only callable by the SetToken's manager.
     *
     * @param setTokenAddress             Address of the SetToken to initialize
     * @param maxManagerFee               Maximum fee that can be charged on issue and redeem
     * @param managerIssueFee             Fee to charge on issuance
     * @param managerRedeemFee            Fee to charge on redemption
     * @param feeRecipient                Address to send fees to
     * @param managerIssuanceHook         Instance of the Manager Contract with the Pre-Issuance Hook function
     * @param txOpts                      Overrides for transaction (optional)
     *
     * @return                            Transaction hash of the initialize transaction
     */
    initializeAsync(setTokenAddress: Address, maxManagerFee: BigNumber, managerIssueFee: BigNumber, managerRedeemFee: BigNumber, feeRecipient: Address, managerIssuanceHook?: Address, callerAddress?: Address, txOpts?: TransactionOverrides): Promise<ContractTransaction>;
    /**
     * Issue a SetToken from its underlying positions
     *
     * @param  setTokenAddress             Address of the SetToken contract to issue
     * @param  quantity                    Quantity to issue
     * @param  setTokenRecipientAddress    Address of the recipient of the issued SetToken
     * @param  callerAddress               Address of caller (optional)
     * @return                             Transaction hash of the issuance transaction
     */
    issueAsync(setTokenAddress: Address, quantity: BigNumber, setTokenRecipientAddress: Address, callerAddress?: Address, txOpts?: TransactionOverrides): Promise<ContractTransaction>;
    /**
     * Redeem a SetToken into its underlying positions
     *
     * @param  setTokenAddress           Address of the SetToken contract
     * @param  quantity                  Quantity to redeem
     * @param  setTokenRecipientAddress  Address of recipient of component tokens from redemption
     * @param  callerAddress             Address of caller (optional)
     * @return                           Transaction hash of the redemption transaction
     */
    redeemAsync(setTokenAddress: Address, quantity: BigNumber, setTokenRecipientAddress: Address, callerAddress?: Address, txOpts?: TransactionOverrides): Promise<ContractTransaction>;
    /**
     * Calculates the amount of each component needed to collateralize passed issue quantity plus fees of Sets as well
     * as amount of debt that will be returned to caller. Values DO NOT take into account any updates from pre action
     * manager or module hooks.
     *
     * @param  setTokenAddress           Address of the SetToken contract
     * @param  quantity                  Quantity to issue
     * @param  callerAddress             Address of caller (optional)
     *
     * @return address[]                 Array of component addresses making up the Set
     * @return BigNumber[]               Array of equity notional amounts of each component, respectively, represented
     *                                   as a BigNumber
     * @return BigNumber[]               Array of debt notional amounts of each component, respectively, represented
     *                                   as a BigNumber
     */
    getRequiredComponentIssuanceUnits(setTokenAddress: Address, quantity: BigNumber, callerAddress?: Address): Promise<(Address | BigNumber)[][]>;
    /**
     * Calculates the amount of each component will be returned on redemption net of fees as well as how much debt needs
     * to be paid down to redeem. Values DO NOT take into account any updates from pre action manager or module hooks.
     *
     * @param  setTokenAddress           Address of the SetToken contract
     * @param  quantity                  Quantity to redeem
     * @param  callerAddress             Address of caller (optional)
     *
     * @return address[]                 Array of component addresses making up the Set
     * @return BigNumber[]               Array of equity notional amounts of each component, respectively, represented as
     *                                   a BigNumber
     * @return BigNumber[]               Array of debt notional amounts of each component, respectively, represented as
     *                                   a BigNumber
     */
    getRequiredComponentRedemptionUnits(setTokenAddress: Address, quantity: BigNumber, callerAddress?: Address): Promise<(Address | BigNumber)[][]>;
    /**
     * Calculates the manager fee, protocol fee and resulting totalQuantity to use when calculating unit amounts. If fees
     * are charged they are added to the total issue quantity, for example 1% fee on 100 Sets means 101 Sets are minted
     * by caller, the _to address receives 100 and the feeRecipient receives 1. Conversely, on redemption the redeemer
     * will only receive the collateral that collateralizes 99 Sets, while the additional Set is given to the
     * feeRecipient.
     *
     * @param setTokenAddress  Instance of the SetToken to issue
     * @param quantity         Amount of SetToken issuer wants to receive/redeem
     * @param isIssue          If issuing or redeeming
     *
     * @return BigNumber       Total amount of Sets to be issued/redeemed with fee adjustment
     * @return BigNumber       Sets minted to the manager
     * @return BigNumber       Sets minted to the protocol
     */
    calculateTotalFeesAsync(setTokenAddress: Address, quantity: BigNumber, isIssue: boolean, callerAddress?: Address): Promise<[
        BigNumber,
        BigNumber,
        BigNumber
    ] & {
        totalQuantity: BigNumber;
        managerFee: BigNumber;
        protocolFee: BigNumber;
    }>;
}
